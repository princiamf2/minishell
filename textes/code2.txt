# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    code2.txt                                          :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/03/25 15:33:07 by mm-furi           #+#    #+#              #
#    Updated: 2025/04/30 11:15:59 by nicolsan         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "minishell.h"

void	add_all_matches_to_cmd(char **matches, t_command *cmd, size_t *argc,
		size_t *capacity)
{
	size_t	i;

	i = 0;
	while (matches[i])
	{
		add_argument_to_cmd(cmd, matches[i], argc, capacity);
		i++;
	}
}

void	free_matches(char **matches)
{
	size_t	i;

	i = 0;
	while (matches[i])
	{
		free(matches[i]);
		i++;
	}
	free(matches);
}

bool	try_expand_glob(t_token **cur, t_command *cmd, size_t *argc,
		size_t *capacity)
{
	char	**matches;

	matches = glob_pattern((*cur)->value);
	if (matches && matches[0])
	{
		add_all_matches_to_cmd(matches, cmd, argc, capacity);
		free_matches(matches);
		*cur = (*cur)->next;
		return (true);
	}
	else
	{
		if (matches)
			free_matches(matches);
		return (false);
	}
}

void	free_command_args(t_command *cmd)
{
	int	i;

	if (!cmd || !cmd->args)
	{
		return ;
	}
	i = 0;
	while (cmd->args[i])
	{
		free(cmd->args[i]);
		i++;
	}
	free(cmd->args);
	cmd->args = NULL;
}

void	free_command_redirs(t_command *cmd)
{
	t_redir	*redir;
	t_redir	*tmp;

	redir = cmd->redirs;
	while (redir)
	{
		tmp = redir->next;
		if (redir->target)
			free(redir->target);
		free(redir);
		redir = tmp;
	}
	cmd->redirs = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builting.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 14:48:15 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 18:53:39 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_builtins(char *cmd)
{
	return (!ft_strcmp(cmd, "cd") || !ft_strcmp(cmd, "echo") || !ft_strcmp(cmd,
			"pwd") || !ft_strcmp(cmd, "export") || !ft_strcmp(cmd, "unset")
		|| !ft_strcmp(cmd, "env") || !ft_strcmp(cmd, "exit"));
}

int	execute_builtin(char **args, t_data *data)
{
	if (!ft_strcmp(args[0], "cd"))
		return (builtin_cd(args));
	if (!ft_strcmp(args[0], "echo"))
		return (builtin_echo(args));
	if (!ft_strcmp(args[0], "pwd"))
		return (builtin_pwd(args));
	if (!ft_strcmp(args[0], "export"))
		return (builtin_export(args, data));
	if (!ft_strcmp(args[0], "unset"))
		return (builtin_unset(args, data));
	if (!ft_strcmp(args[0], "env"))
		return (builtin_env(env_to_array(data->env)));
	if (!ft_strcmp(args[0], "exit"))
		return (builtin_exit(args, data));
	return (0);
}

int	builtin_echo(char **args)
{
	int	i;
	int	nline;

	i = 1;
	nline = 1;
	while (args[i] && is_option_n(args[i]))
	{
		nline = 0;
		i++;
	}
	while (args[i])
	{
		ft_putstr_fd(args[i], 1);
		if (args[i + 1])
			ft_putstr_fd(" ", 1);
		i++;
	}
	if (nline)
		ft_putstr_fd("\n", 1);
	return (0);
}

int	builtin_pwd(char **args)
{
	char	path[4096];

	(void)args;
	if (getcwd(path, sizeof(path)) == NULL)
	{
		perror("pwd");
		return (1);
	}
	ft_putstr_fd(path, 1);
	ft_putchar_fd('\n', 1);
	return (0);
}

int	compare_env_vars(const void *a, const void *b)
{
	return (strcmp(*(const char **)a, *(const char **)b));
}

void	free_env_array(char **env_array)
{
	int	i;

	if (!env_array)
		return ;
	i = 0;
	while (env_array[i] != NULL)
	{
		free(env_array[i]);
		i++;
	}
	free(env_array);
}

void	_print_export_key_value(const char *env_var, const char *equal_sign)
{
	char		*key;
	const char	*value;
	size_t		key_len;

	key_len = equal_sign - env_var;
	key = malloc(key_len + 1);
	if (key)
	{
		ft_memcpy(key, env_var, key_len);
		key[key_len] = '\0';
		value = equal_sign + 1;
		ft_putstr_fd("declare -x ", 1);
		ft_putstr_fd(key, 1);
		ft_putstr_fd("=\"", 1);
		ft_putstr_fd((char *)value, 1);
		ft_putstr_fd("\"\n", 1);
		free(key);
	}
	else
	{
		perror("minishell: malloc (_print_export_key_value key)");
		ft_putstr_fd((char *)env_var, 1);
		ft_putchar_fd('\n', 1);
	}
}

void	_print_export_key_only(const char *env_var)
{
	ft_putstr_fd("declare -x ", 1);
	ft_putstr_fd((char *)env_var, 1);
	ft_putchar_fd('\n', 1);
}

void	print_export_formatted(const char *env_var)
{
	const char	*equal_sign;

	if (!env_var)
		return ;
	equal_sign = ft_strchr(env_var, '=');
	if (equal_sign)
	{
		_print_export_key_value(env_var, equal_sign);
	}
	else
	{
		_print_export_key_only(env_var);
	}
}

int	handle_export_no_args(t_data *data)
{
	char	**env_array;
	int		i;
	int		count;

	env_array = env_to_array(data->env);
	if (!env_array)
		return (1);
	count = 0;
	while (env_array[count] != NULL)
		count++;
	if (count > 0)
		qsort(env_array, count, sizeof(char *), compare_env_vars);
	i = 0;
	while (env_array[i])
	{
		print_export_formatted(env_array[i]);
		i++;
	}
	free_env_array(env_array);
	return (0);
}

int	builtin_export(char **args, t_data *data)
{
	if (!args || !args[0])
		return (1);
	if (!args[1])
	{
		return (handle_export_no_args(data));
	}
	else
	{
		return (handle_export_arguments(args, data));
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builting2.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 17:36:34 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:29:15 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	builtin_unset(char **args, t_data *data)
{
	if (!args[1])
		return (0);
	return (handle_unset_arguments(args, data));
}

int	handle_unset_arguments(char **args, t_data *data)
{
	int	i;
	int	ret_status;

	ret_status = 0;
	i = 1;
	while (args[i])
	{
		if (!is_valid_identifier(args[i]))
		{
			ft_putstr_fd("minishell: unset: `", 2);
			ft_putstr_fd(args[i], 2);
			ft_putstr_fd("': not a valid identifier\n", 2);
			ret_status = 1;
		}
		else
		{
			unset_env_variable(&(data->env), args[i]);
		}
		i++;
	}
	return (ret_status);
}

void	unset_env_variable(t_env **env, char *key)
{
	t_env	*node;
	t_env	*prev;

	node = *env;
	prev = NULL;
	while (node)
	{
		if (ft_strcmp(node->key, key) == 0)
		{
			if (prev)
				prev->next = node->next;
			else
				*env = node->next;
			free_env_variable(node);
			return ;
		}
		prev = node;
		node = node->next;
	}
}

int	builtin_env(char **env)
{
	int	i;

	i = 0;
	while (env[i])
	{
		ft_putstr_fd(env[i], 1);
		ft_putchar_fd('\n', 1);
		i++;
	}
	return (0);
}

int	builtin_cd(char **args)
{
	char	*path;

	if (!args[1])
	{
		path = getenv("HOME");
		if (!path)
		{
			ft_putstr_fd("cd : HOME not set\n", 2);
			return (1);
		}
	}
	else
		path = args[1];
	if (chdir(path) != 0)
	{
		perror("cd");
		return (1);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cmd_execution.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 22:14:29 by michel            #+#    #+#             */
/*   Updated: 2025/04/26 18:54:15 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_cmdlist(t_cmdlist *commands, t_data *data)
{
	int			last_status;
	t_cmdlist	*node;

	last_status = data->exit_status;
	node = commands;
	while (node)
	{
		if (!node->andor)
		{
			last_status = 1;
			node = node->next;
			continue ;
		}
		last_status = execute_andor(node->andor, data);
		node = node->next;
	}
	return (last_status);
}

int	execute_andor(t_andor *list, t_data *data)
{
	int	result;

	if (!list || !list->pipeline)
		return (1);
	result = execute_full_command(list->pipeline, data);
	list = list->next;
	while (list)
	{
		if (list->op == AND_IF && result != 0)
			break ;
		if (list->op == OR_IF && result == 0)
			break ;
		if (!list->pipeline)
		{
			result = 1;
			break ;
		}
		result = execute_full_command(list->pipeline, data);
		list = list->next;
	}
	return (result);
}

void	free_cmdlist(t_cmdlist *list)
{
	t_cmdlist	*next;

	while (list)
	{
		next = list->next;
		free_andor(list->andor);
		free(list);
		list = next;
	}
}

void	free_andor(t_andor *andor)
{
	t_andor	*next;

	while (andor)
	{
		next = andor->next;
		free_command(andor->pipeline);
		free(andor);
		andor = next;
	}
}

bool	_save_original_fds(int *saved_stdin_ptr, int *saved_stdout_ptr)
{
	*saved_stdin_ptr = dup(STDIN_FILENO);
	*saved_stdout_ptr = dup(STDOUT_FILENO);
	if (*saved_stdin_ptr < 0 || *saved_stdout_ptr < 0)
	{
		perror("dup");
		if (*saved_stdin_ptr >= 0)
			close(*saved_stdin_ptr);
		if (*saved_stdout_ptr >= 0)
			close(*saved_stdout_ptr);
		*saved_stdin_ptr = -1;
		*saved_stdout_ptr = -1;
		return (false);
	}
	return (true);
}

void	_restore_original_fds(int saved_stdin, int saved_stdout)
{
	if (saved_stdin >= 0)
	{
		if (dup2(saved_stdin, STDIN_FILENO) < 0)
			perror("dup2 stdin restore");
		close(saved_stdin);
	}
	if (saved_stdout >= 0)
	{
		if (dup2(saved_stdout, STDOUT_FILENO) < 0)
			perror("dup2 stdout restore");
		close(saved_stdout);
	}
}

int	execute_builtin_with_redir(t_command *cmd, t_data *data)
{
	int	saved_stdin;
	int	saved_stdout;
	int	ret;

	saved_stdin = -1;
	saved_stdout = -1;
	if (!_save_original_fds(&saved_stdin, &saved_stdout))
		return (1);
	if (handle_redirection(cmd) < 0)
	{
		_restore_original_fds(saved_stdin, saved_stdout);
		return (1);
	}
	ret = execute_builtin(cmd->args, data);
	_restore_original_fds(saved_stdin, saved_stdout);
	data->exit_status = ret;
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   cmd_management.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 22:24:42 by michel            #+#    #+#             */
/*   Updated: 2025/04/26 17:46:18 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_command(t_command *cmd)
{
	t_command	*next_pipe_to_free;

	if (!cmd)
		return ;
	next_pipe_to_free = cmd->next_pipe;
	if (!cmd->subshell)
		free_command_args(cmd);
	free_command_redirs(cmd);
	if (cmd->input)
		free(cmd->input);
	if (cmd->output)
		free(cmd->output);
	if (cmd->subshell && cmd->subshell_ast)
		free_cmdlist(cmd->subshell_ast);
	free(cmd);
	if (next_pipe_to_free)
		free_command(next_pipe_to_free);
}

int	count_commands(t_command *pipeline)
{
	int	count;

	count = 0;
	while (pipeline)
	{
		count++;
		pipeline = pipeline->next_pipe;
	}
	return (count);
}

t_command	*init_command(void)
{
	t_command	*cmd;

	cmd = malloc(sizeof(t_command));
	if (!cmd)
	{
		perror("malloc");
		return (NULL);
	}
	cmd->args = NULL;
	cmd->input = NULL;
	cmd->output = NULL;
	cmd->append = 0;
	cmd->heredoc = 0;
	cmd->subshell = false;
	cmd->redirs = NULL;
	cmd->next_pipe = NULL;
	cmd->subshell_ast = NULL;
	return (cmd);
}

int	update_env_var(t_data *data, char *key, char *value)
{
	t_env	*node;
	size_t	key_len;

	node = data->env;
	key_len = ft_strlen(key);
	while (node)
	{
		if (ft_strncmp(node->key, key, key_len) == 0
			&& node->key[key_len] == '\0')
		{
			free(node->value);
			node->value = ft_strdup(value);
			return (1);
		}
		node = node->next;
	}
	return (0);
}

int	add_env_var(t_data *data, char *key, char *value)
{
	t_env	*new_node;

	new_node = malloc(sizeof(t_env));
	if (!new_node)
	{
		perror("malloc");
		free(key);
		free(value);
		return (1);
	}
	new_node->key = key;
	new_node->value = value;
	new_node->next = data->env;
	data->env = new_node;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   command_assembly.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 15:07:51 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 18:57:20 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool	ensure_args_capacity(t_command *cmd, size_t argc, size_t *capacity)
{
	char	**tmp;
	size_t	old_size;
	size_t	new_capacity;

	if (argc + 1 >= *capacity)
	{
		old_size = *capacity * sizeof(char *);
		if (*capacity == 0)
			new_capacity = 8;
		else
			new_capacity = *capacity * 2;
		tmp = ft_realloc(cmd->args, old_size, new_capacity * sizeof(char *));
		if (!tmp)
		{
			perror("minishell: ft_realloc in ensure_args_capacity");
			return (false);
		}
		cmd->args = tmp;
		*capacity = new_capacity;
	}
	return (true);
}

void	add_argument_to_cmd(t_command *cmd, const char *raw_arg_value,
		size_t *argc, size_t *capacity)
{
	char	*final_arg;
	bool	args_ready;

	if (!cmd || !raw_arg_value || !argc || !capacity)
		return ;
	final_arg = interpret_raw_value(raw_arg_value);
	if (!final_arg)
	{
		perror("minishell: interpret_raw_value failed");
		return ;
	}
	if (!cmd->args)
		args_ready = (init_cmd_args(cmd, capacity, argc) == 0);
	else
		args_ready = ensure_args_capacity(cmd, *argc, capacity);
	if (!args_ready)
	{
		free(final_arg);
		return ;
	}
	cmd->args[*argc] = final_arg;
	(*argc)++;
	cmd->args[*argc] = NULL;
}

void	_get_interp_params(const char *raw_value, t_interp_params *params)
{
	params->len = ft_strlen(raw_value);
	params->quote_char = 0;
	params->start = 0;
	params->end = params->len;
	if (params->len >= 2)
	{
		if (raw_value[0] == '\'' && raw_value[params->len - 1] == '\'')
		{
			params->quote_char = '\'';
			params->start = 1;
			params->end = params->len - 1;
		}
		else if (raw_value[0] == '\"' && raw_value[params->len - 1] == '\"')
		{
			params->quote_char = '\"';
			params->start = 1;
			params->end = params->len - 1;
		}
	}
}

void	_process_char_for_interpretation(t_interp_ctx *ctx)
{
	char	current_char;
	char	next_char;

	current_char = ctx->raw[*(ctx->i_ptr)];
	if (current_char == '\\' && (*(ctx->i_ptr) + 1) < ctx->params.end)
	{
		next_char = ctx->raw[*(ctx->i_ptr) + 1];
		if (ctx->params.quote_char == '\"')
		{
			if (next_char == '\\' || next_char == '$' || next_char == '\"')
			{
				ctx->res[(*(ctx->res_idx_ptr))++] = next_char;
				(*(ctx->i_ptr))++;
			}
			else
				ctx->res[(*(ctx->res_idx_ptr))++] = current_char;
		}
		else
		{
			ctx->res[(*(ctx->res_idx_ptr))++] = next_char;
			(*(ctx->i_ptr))++;
		}
	}
	else
		ctx->res[(*(ctx->res_idx_ptr))++] = current_char;
}

size_t	_interpret_and_copy(char *result, const char *raw_value,
		t_interp_params params)
{
	t_interp_ctx	ctx;
	size_t			i;
	size_t			result_idx;

	i = params.start;
	result_idx = 0;
	ctx.raw = raw_value;
	ctx.res = result;
	ctx.i_ptr = &i;
	ctx.res_idx_ptr = &result_idx;
	ctx.params = params;
	while (*(ctx.i_ptr) < ctx.params.end)
	{
		if (ctx.params.quote_char == '\'')
			ctx.res[(*(ctx.res_idx_ptr))++] = ctx.raw[*(ctx.i_ptr)];
		else
			_process_char_for_interpretation(&ctx);
		(*(ctx.i_ptr))++;
	}
	return (*(ctx.res_idx_ptr));
}

char	*interpret_raw_value(const char *raw_value)
{
	t_interp_params	params;
	char			*result;
	size_t			result_final_idx;

	if (!raw_value)
		return (NULL);
	_get_interp_params(raw_value, &params);
	result = malloc(params.len + 1);
	if (!result)
		return (NULL);
	result_final_idx = _interpret_and_copy(result, raw_value, params);
	result[result_final_idx] = '\0';
	return (result);
}

bool	_handle_redir_output(t_command *cmd, const char *target_val,
		t_token_type type)
{
	if (cmd->output)
		free(cmd->output);
	cmd->output = interpret_raw_value(target_val);
	if (!cmd->output)
	{
		perror("minishell: interpret_raw_value for output failed");
		return (false);
	}
	cmd->append = (type == REDIR_APPEND);
	return (true);
}

bool	_handle_redir_input(t_command *cmd, const char *target_val)
{
	if (cmd->input)
		free(cmd->input);
	cmd->input = interpret_raw_value(target_val);
	if (!cmd->input)
	{
		perror("minishell: interpret_raw_value for input failed");
		return (false);
	}
	cmd->heredoc = 0;
	return (true);
}

bool	_handle_redir_heredoc(t_command *cmd, const char *target_val)
{
	if (cmd->input)
		free(cmd->input);
	cmd->input = ft_strdup(target_val);
	if (!cmd->input)
	{
		perror("minishell: ft_strdup for heredoc delimiter failed");
		return (false);
	}
	cmd->heredoc = 1;
	return (true);
}

void	parse_redirection(t_command *cmd, t_token **cur)
{
	t_token	*redir_token;
	t_token	*target_token;
	bool	success;

	redir_token = *cur;
	if (!redir_token->next || !redir_token->next->value)
		return ;
	target_token = redir_token->next;
	success = false;
	if (redir_token->type == REDIR_OUT || redir_token->type == REDIR_APPEND)
		success = _handle_redir_output(cmd, target_token->value,
				redir_token->type);
	else if (redir_token->type == REDIR_IN)
		success = _handle_redir_input(cmd, target_token->value);
	else if (redir_token->type == HEREDOC)
		success = _handle_redir_heredoc(cmd, target_token->value);
	if (success)
		*cur = target_token->next;
}

bool	_parse_andor_append(t_andor **tail_ptr, t_token **cur)
{
	t_token_type	op;
	t_command		*next_pipeline;
	t_andor			*node;

	op = (*cur)->type;
	*cur = (*cur)->next;
	if (!*cur)
		return (false);
	next_pipeline = parse_pipeline(cur);
	if (!next_pipeline)
		return (false);
	node = init_andor(next_pipeline);
	if (!node)
	{
		free_command(next_pipeline);
		return (false);
	}
	node->op = op;
	(*tail_ptr)->next = node;
	*tail_ptr = node;
	return (true);
}

t_andor	*parse_andor(t_token **cur)
{
	t_command	*first_pipeline;
	t_andor		*head;
	t_andor		*tail;

	head = NULL;
	first_pipeline = parse_pipeline(cur);
	if (!first_pipeline)
		return (NULL);
	head = init_andor(first_pipeline);
	if (!head)
	{
		free_command(first_pipeline);
		return (NULL);
	}
	tail = head;
	while (*cur && ((*cur)->type == AND_IF || (*cur)->type == OR_IF))
	{
		if (!_parse_andor_append(&tail, cur))
		{
			free_andor(head);
			return (NULL);
		}
	}
	return (head);
}

void	append_andor(t_andor *head, t_andor *node)
{
	t_andor	*cur;

	cur = head;
	while (cur->next)
		cur = cur->next;
	cur->next = node;
}

t_andor	*init_andor(t_command *pipeline)
{
	t_andor	*andor;

	andor = malloc(sizeof(t_andor));
	if (!andor)
	{
		perror("malloc");
		return (NULL);
	}
	andor->pipeline = pipeline;
	andor->op = 0;
	andor->next = NULL;
	return (andor);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 18:05:24 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/11 11:12:13 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_env	*create_env_node(char *env_entry)
{
	t_env	*node;
	char	*equal;

	equal = ft_strchr(env_entry, '=');
	if (!equal)
		return (NULL);
	node = malloc(sizeof(t_env));
	if (!node)
	{
		perror("malloc");
		return (NULL);
	}
	node->key = ft_substr(env_entry, 0, equal - env_entry);
	node->value = ft_strdup(equal + 1);
	node->next = NULL;
	return (node);
}

void	add_env_node(t_env **head, t_env *new_node)
{
	if (!new_node)
		return ;
	new_node->next = *head;
	*head = new_node;
}

t_env	*env_init(char **envp)
{
	t_env	*head;
	t_env	*node;
	int		i;

	head = NULL;
	i = 0;
	while (envp[i])
	{
		node = create_env_node(envp[i]);
		add_env_node(&head, node);
		i++;
	}
	return (head);
}

char	*env_get(t_env *env, const char *key)
{
	size_t	key_len;

	key_len = ft_strlen(key);
	while (env)
	{
		if (ft_strncmp(env->key, key, key_len) == 0
			&& env->key[key_len] == '\0')
			return (env->value);
		env = env->next;
	}
	return (NULL);
}

void	env_set(t_env **env, const char *key, const char *val)
{
	t_env	*node;

	node = find_env_node(*env, key);
	if (node)
	{
		update_node_value(node, val);
		return ;
	}
	node = create_env_node2(key, val);
	if (!node)
		return ;
	node->next = *env;
	*env = node;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 14:48:36 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 19:02:42 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*find_excutable(const char *cmd, t_env *env)
{
	char	*paths;
	char	*full_path;

	paths = get_path_env(env);
	if (!paths)
		return (NULL);
	full_path = search_executable_in_paths(paths, cmd);
	free(paths);
	return (full_path);
}

char	*get_executable_path(t_command *cmd, t_data *data)
{
	if (ft_strchr(cmd->args[0], '/') != NULL)
		return (ft_strdup(cmd->args[0]));
	return (find_excutable(cmd->args[0], data->env));
}

int	_handle_exec_path_not_found(t_command *cmd, int saved_stdin,
		int saved_stdout)
{
	ft_putstr_fd("minishell: ", 2);
	if (cmd && cmd->args && cmd->args[0])
		ft_putstr_fd(cmd->args[0], 2);
	else
		ft_putstr_fd("(null)", 2);
	ft_putstr_fd(": command not found\n", 2);
	_restore_original_fds(saved_stdin, saved_stdout);
	return (127);
}

int	execute_external_command(t_command *cmd, t_data *data)
{
	char	*exec_path;
	int		status;
	int		saved_stdin;
	int		saved_stdout;

	saved_stdin = -1;
	saved_stdout = -1;
	if (!_save_original_fds(&saved_stdin, &saved_stdout))
		return (1);
	if (handle_redirection(cmd) < 0)
	{
		_restore_original_fds(saved_stdin, saved_stdout);
		return (1);
	}
	exec_path = get_executable_path(cmd, data);
	if (!exec_path)
	{
		return (_handle_exec_path_not_found(cmd, saved_stdin, saved_stdout));
	}
	status = fork_and_execute_no_redir(exec_path, cmd, data);
	free(exec_path);
	_restore_original_fds(saved_stdin, saved_stdout);
	return (status);
}

int	_dispatch_execution(t_command *cmd, t_data *data)
{
	int	status;

	if (is_builtins(cmd->args[0]))
	{
		status = execute_builtin_with_redir(cmd, data);
	}
	else
	{
		status = execute_external_command(cmd, data);
	}
	return (status);
}

int	execute_command(t_command *cmd, t_data *data)
{
	int	saved_stdin;
	int	saved_stdout;
	int	status;
	int	no_args_ret;

	if (!cmd)
		return (1);
	saved_stdin = -1;
	saved_stdout = -1;
	if (!_save_original_fds(&saved_stdin, &saved_stdout))
		return (1);
	no_args_ret = handle_no_command_arguments(cmd, saved_stdin, saved_stdout);
	if (no_args_ret != -1)
	{
		data->exit_status = no_args_ret;
		return (no_args_ret);
	}
	status = _dispatch_execution(cmd, data);
	_restore_original_fds(saved_stdin, saved_stdout);
	data->exit_status = status;
	return (status);
}

int	execute_full_command(t_command *cmd, t_data *data)
{
	int	status;

	status = 1;
	if (!cmd)
		return (status);
	if (cmd->subshell)
		status = execute_subshell(cmd, data);
	else if (cmd->next_pipe)
		status = execute_pipeline(cmd, data);
	else
		status = execute_command(cmd, data);
	return (status);
}

void	child_process_subshell(t_command *cmd, t_data *data)
{
	int	exit_status;

	if (handle_redirection(cmd) < 0)
		exit(1);
	exit_status = execute_cmdlist(cmd->subshell_ast, data);
	exit(exit_status);
}

int	parent_process_subshell(pid_t pid)
{
	int	status;

	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
	{
		return (WEXITSTATUS(status));
	}
	else if (WIFSIGNALED(status))
	{
		return (128 + WTERMSIG(status));
	}
	else
	{
		return (1);
	}
}

int	execute_subshell(t_command *cmd, t_data *data)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		perror("minishell: fork");
		return (1);
	}
	if (pid == 0)
	{
		child_process_subshell(cmd, data);
	}
	else
	{
		return (parent_process_subshell(pid));
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 23:51:31 by michel            #+#    #+#             */
/*   Updated: 2025/04/26 19:04:52 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	*create_pipes(int n)
{
	int	*pipes;
	int	i;

	if (n < 2)
		return (NULL);
	pipes = malloc(2 * (n - 1) * sizeof(int));
	if (!pipes)
		return (NULL);
	i = 0;
	while (i < n - 1)
	{
		if (pipe(&pipes[i * 2]) < 0)
		{
			free(pipes);
			return (NULL);
		}
		i++;
	}
	return (pipes);
}

void	setup_pipes_for_child(int index, t_pipe_info *pi)
{
	if (index > 0)
	{
		if (dup2(pi->pipes[(index - 1) * 2], STDIN_FILENO) < 0)
			exit(1);
	}
	if (index < pi->n - 1)
	{
		if (dup2(pi->pipes[index * 2 + 1], STDOUT_FILENO) < 0)
			exit(1);
	}
}

void	close_unused_pipes(t_pipe_info *pi)
{
	int	j;

	j = 0;
	while (j < 2 * (pi->n - 1))
	{
		close(pi->pipes[j]);
		j++;
	}
}

void	_free_str_array(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

void	_execute_external_in_child(t_command *cmd, t_data *data)
{
	char	*exec_path;
	char	**env_array;

	if (ft_strchr(cmd->args[0], '/') != NULL)
		exec_path = ft_strdup(cmd->args[0]);
	else
		exec_path = find_excutable(cmd->args[0], data->env);
	if (!exec_path)
	{
		ft_putstr_fd("minishell: ", 2);
		ft_putstr_fd(cmd->args[0], 2);
		ft_putstr_fd(": command not found\n", 2);
		exit(127);
	}
	env_array = env_to_array(data->env);
	execve(exec_path, cmd->args, env_array);
	perror("minishell: execve");
	_free_str_array(env_array);
	free(exec_path);
	exit(126);
}

void	execute_builtin_or_command(t_command *cmd, t_data *data)
{
	if (!cmd || !cmd->args || !cmd->args[0])
		exit(1);
	if (is_builtins(cmd->args[0]))
		exit(execute_builtin(cmd->args, data));
	_execute_external_in_child(cmd, data);
}

int	execute_child(t_command *cmd, int index, t_pipe_info *pi, t_data *data)
{
	setup_pipes_for_child(index, pi);
	close_unused_pipes(pi);
	if (handle_redirection(cmd) < 0)
		exit(1);
	execute_builtin_or_command(cmd, data);
	return (0);
}

int	is_valid_identifier(const char *str)
{
	int	i;

	if (!str || (!ft_isalpha(str[0]) && str[0] != '_'))
		return (0);
	i = 1;
	while (str[i])
	{
		if (!ft_isalnum(str[i]) && str[i] != '_')
			return (0);
		i++;
	}
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exit.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/04 14:25:50 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 19:07:21 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_numeric(const char *str)
{
	int	i;

	i = 0;
	if (!str || !str[0])
		return (0);
	if (str[i] == '+' || str[i] == '-')
		i++;
	while (str[i])
	{
		if (!ft_isdigit(str[i]))
			return (0);
		i++;
	}
	return (1);
}

void	free_all_data(t_data *data)
{
	if (!data)
		return ;
	if (data->input)
	{
		free(data->input);
		data->input = NULL;
	}
	if (data->tokens)
	{
		free_tokens(data->tokens);
		data->tokens = NULL;
	}
	if (data->cmdlist)
	{
		free_cmdlist(data->cmdlist);
		data->cmdlist = NULL;
	}
	if (data->env)
	{
		free_env(data->env);
		data->env = NULL;
	}
	free(data);
}

int	_calculate_exit_code(char **args, int current_status)
{
	int	status;

	if (!args[1])
	{
		status = current_status;
	}
	else
	{
		if (!is_numeric(args[1]))
		{
			ft_putstr_fd("minishell: exit: ", 2);
			ft_putstr_fd(args[1], 2);
			ft_putstr_fd(": numeric argument required\n", 2);
			status = 255;
		}
		else
		{
			status = ft_atoi(args[1]) % 256;
		}
	}
	return (status);
}

int	builtin_exit(char **args, t_data *data)
{
	int	final_exit_status;

	ft_putendl_fd("exit", 2);
	if (args[1] && args[2])
	{
		ft_putstr_fd("minishell: exit: too many arguments\n", 2);
		data->exit_status = 1;
		return (1);
	}
	final_exit_status = _calculate_exit_code(args, data->exit_status);
	free_all_data(data);
	exit(final_exit_status);
	return (final_exit_status);
}

void	process_local_assignmment(char *input, t_data *data)
{
	char	*eq;

	eq = ft_strchr(input, '=');
	if (!eq)
		return ;
	*eq = '\0';
	local_set(&(data->local_vars), input, eq + 1);
	*eq = '=';
}

void	local_set(t_env **local, const char *key, const char *val)
{
	t_env	*node;

	node = find_env_node(*local, key);
	if (node)
		update_node_value(node, val);
	else
	{
		node = create_env_node2(key, val);
		if (!node)
		{
			ft_putendl_fd("local_set: malloc\n", 2);
			return ;
		}
		node->next = *local;
		*local = node;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   export_utils.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:04:31 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 19:44:38 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_export_arguments(char **args, t_data *data)
{
	int	i;
	int	ret_status;

	ret_status = 0;
	if (!args || !args[1])
		return (0);
	i = 1;
	while (args[i])
	{
		if (process_export_argument(args[i], data) != 0)
			ret_status = 1;
		i++;
	}
	return (ret_status);
}

bool	_extract_export_kv(char *arg, t_export_kv *kv)
{
	kv->eq = ft_strchr(arg, '=');
	if (kv->eq)
	{
		kv->key = extract_key(arg, kv->eq);
		kv->raw_value = extract_value(kv->eq);
	}
	else
	{
		kv->key = ft_strdup(arg);
		kv->raw_value = NULL;
	}
	if (!kv->key)
	{
		perror("minishell: strdup/substr failed for export key");
		free(kv->raw_value);
		return (false);
	}
	return (true);
}

bool	_validate_export_key(const char *key, char *arg_for_error)
{
	if (!is_valid_identifier(key))
	{
		ft_putstr_fd("minishell: export: `", 2);
		ft_putstr_fd(arg_for_error, 2);
		ft_putstr_fd("': not a valid identifier\n", 2);
		return (false);
	}
	return (true);
}

int	_update_or_add_env_var(t_data *data, char *key, char *final_value)
{
	if (update_env_var(data, key, final_value))
	{
		free(key);
		free(final_value);
	}
	else
	{
		if (add_env_var(data, key, final_value))
		{
			return (1);
		}
	}
	return (0);
}

int	_process_and_update_env(t_data *data, t_export_kv *kv)
{
	char	*final_value;

	if (!kv->eq || !kv->raw_value)
	{
		free(kv->key);
		free(kv->raw_value);
		return (0);
	}
	final_value = interpret_raw_value(kv->raw_value);
	free(kv->raw_value);
	kv->raw_value = NULL;
	if (!final_value)
	{
		perror("minishell: interpret_raw_value failed for export value");
		free(kv->key);
		return (1);
	}
	return (_update_or_add_env_var(data, kv->key, final_value));
}

int	process_export_argument(char *arg, t_data *data)
{
	t_export_kv	kv;

	kv.key = NULL;
	kv.raw_value = NULL;
	if (!_extract_export_kv(arg, &kv))
		return (1);
	if (!_validate_export_key(kv.key, arg))
	{
		free(kv.key);
		free(kv.raw_value);
		return (1);
	}
	return (_process_and_update_env(data, &kv));
}

char	*extract_key(char *arg, char *eq)
{
	size_t	key_len;

	key_len = eq - arg;
	return (ft_substr(arg, 0, key_len));
}

char	*extract_value(char *eq)
{
	return (ft_strdup(eq + 1));
}

void	free_env_variable(t_env *node)
{
	if (!node)
		return ;
	free(node->key);
	free(node->value);
	free(node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils14.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 15:39:57 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/01 15:19:20 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool	process_heredoc_line(const char *delim, char **content, size_t *len,
		size_t *cap)
{
	char	*line;

	line = readline("> ");
	if (!line)
		return (true);
	if (ft_strcmp(line, delim) == 0)
	{
		free(line);
		return (true);
	}
	append_line(content, len, cap, line);
	free(line);
	return (false);
}

bool	is_valid_entry(struct dirent *entry)
{
	return (ft_strcmp(entry->d_name, ".") != 0 && ft_strcmp(entry->d_name,
			"..") != 0);
}

int	process_directory_entries(t_globinfo *info, const char *dirpath,
		const char *pat)
{
	struct dirent	*entry;

	entry = readdir(info->dir);
	while (entry != NULL)
	{
		if (!is_valid_entry(entry))
		{
			entry = readdir(info->dir);
			continue ;
		}
		if (match_pattern(pat, entry->d_name))
		{
			if (add_match(info, dirpath, entry->d_name) == -1)
				return (-1);
		}
		entry = readdir(info->dir);
	}
	return (0);
}

char	**finalize_matches(char **matches, size_t count)
{
	char	**tmp;
	size_t	old_size;

	old_size = (count + 1) * sizeof(char *);
	tmp = ft_realloc(matches, old_size, (count + 1) * sizeof(char *));
	if (tmp)
	{
		tmp[count] = NULL;
		return (tmp);
	}
	return (matches);
}

void	free_pipeline(t_command *cmd)
{
	t_command	*next;

	while (cmd)
	{
		next = cmd->next_pipe;
		free_command(cmd);
		cmd = next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   heredoc_file_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/09 02:03:50 by michel            #+#    #+#             */
/*   Updated: 2025/04/26 20:06:37 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*generate_tmp_name(void)
{
	static int	counter;
	char		*prefix;
	char		*num_str;
	char		*tmp_name;
	static int	init;

	if (!init)
	{
		counter = 0;
		init = 1;
	}
	prefix = "/tmp/minishell_heredoc_";
	num_str = ft_itoa(counter);
	tmp_name = ft_strjoin(prefix, num_str);
	free(num_str);
	counter++;
	return (tmp_name);
}

int	open_tmp_heredoc_file(char **tmp_name)
{
	int	fd;

	*tmp_name = generate_tmp_name();
	unlink(*tmp_name);
	fd = open(*tmp_name, O_WRONLY | O_CREAT | O_EXCL, 0600);
	return (fd);
}

bool	_process_heredoc_input_line(int fd, const char *interpreted_delimiter)
{
	char	*line;

	bool should_break ;
	should_break = false;
	line = readline("herdoc> ");
	if (!line)
	{
		should_break = true;
	}
	else
	{
		if (ft_strcmp(line, interpreted_delimiter) == 0)
		{
			should_break = true;
		}
		else
		{
			write(fd, line, ft_strlen(line));
			write(fd, "\n", 1);
		}
		free(line);
	}
	return (should_break);
}

int	read_and_write_heredoc(int fd, const char *raw_delimiter)
{
	char	*interpreted_delimiter;

	interpreted_delimiter = interpret_raw_value(raw_delimiter);
	if (!interpreted_delimiter)
	{
		perror("minishell: interpret_raw_value failed for heredoc delimiter");
		return (-1);
	}
	while (true)
	{
		if (_process_heredoc_input_line(fd, interpreted_delimiter))
			break ;
	}
	free(interpreted_delimiter);
	return (0);
}

int	finalize_heredoc(int fd, char *tmp_name)
{
	int	ret;
	int	final_ret;

	close(fd);
	fd = open(tmp_name, O_RDONLY);
	if (fd < 0)
	{
		perror("open heredoc (finalize)");
		free(tmp_name);
		return (-1);
	}
	ret = dup2(fd, STDIN_FILENO);
	close(fd);
	unlink(tmp_name);
	free(tmp_name);
	if (ret >= 0)
		final_ret = 0;
	else
		final_ret = -1;
	return (final_ret);
}

void	print_env_array(char **env_array)
{
	int	i;

	i = 0;
	if (!env_array)
	{
		printf("env_array est NULL\n");
		return ;
	}
	while (env_array[i])
	{
		printf("%s\n", env_array[i]);
		i++;
	}
}

t_redir	*find_heredoc_redir(t_redir *redirs)
{
	while (redirs)
	{
		if (redirs->type == HEREDOC)
		{
			return (redirs);
		}
		redirs = redirs->next;
	}
	return (NULL);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 16:06:56 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 19:33:47 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_token_state	initialize_token_state(const char *input)
{
	t_token_state	state;

	state.input = input;
	state.i = 0;
	state.in_single = false;
	state.in_double = false;
	state.buffer = malloc(sizeof(t_buffer));
	if (!state.buffer)
	{
		perror("malloc");
		exit(1);
	}
	state.buffer->cap = 4096;
	state.buffer->index = 0;
	state.buffer->str = malloc(state.buffer->cap);
	if (!state.buffer->str)
	{
		free(state.buffer);
		perror("malloc");
		exit(1);
	}
	return (state);
}

void	cleanup_token_state(t_token_state *state)
{
	free(state->buffer->str);
	free(state->buffer);
}

void	append_token_to_list(t_token **head, t_token **tail, t_token *new_token)
{
	if (!*head)
	{
		*head = new_token;
		*tail = new_token;
	}
	else
	{
		(*tail)->next = new_token;
		*tail = new_token;
	}
}

void	_qualify_token_quoting(t_token *token, t_token_state *state,
		size_t start_idx)
{
	size_t	end_idx;

	end_idx = state->i;
	if (end_idx > start_idx && (end_idx - start_idx >= 2))
	{
		if ((state->input[start_idx] == '\'' && state->input[end_idx
				- 1] == '\'') || (state->input[start_idx] == '\"'
				&& state->input[end_idx - 1] == '\"'))
		{
			token->quoted = true;
		}
	}
}
bool	_handle_empty_raw_token(char *raw_value, t_token_state *state,
		size_t *i_ptr)
{
	if (ft_strlen(raw_value) == 0)
	{
		free(raw_value);
		*i_ptr = skip_whitespace(state->input, state->i);
		return (true);
	}
	return (false);
}

bool	_process_token_loop_step(t_token_list *list, t_token_state *state,
		t_data *data, size_t *i_ptr)
{
	char	*raw_value;
	t_token	*new_token;
	size_t	token_start_index;

	token_start_index = *i_ptr;
	state->i = *i_ptr;
	state->buffer->index = 0;
	raw_value = collect_token(state, data);
	if (!raw_value)
		return (false);
	if (_handle_empty_raw_token(raw_value, state, i_ptr))
		return (true);
	new_token = create_token(raw_value);
	if (!new_token)
	{
		free(raw_value);
		return (false);
	}
	_qualify_token_quoting(new_token, state, token_start_index);
	append_token_to_list(&(list->head), &(list->tail), new_token);
	free(raw_value);
	*i_ptr = skip_whitespace(state->input, state->i);
	return (true);
}

t_token	*process_tokens(t_token_state *state, t_data *data)
{
	t_token_list	list;
	size_t			i;

	i = skip_whitespace(state->input, 0);
	list.head = NULL;
	list.tail = NULL;
	while (state->input[i])
	{
		if (!_process_token_loop_step(&list, state, data, &i))
		{
			free_tokens(list.head);
			return (NULL);
		}
	}
	return (list.head);
}

t_token	*lexer(const char *input, t_env *env, t_data *data)
{
	t_token_state	state;
	t_token			*head;

	state = initialize_token_state(input);
	head = process_tokens(&state, data);
	cleanup_token_state(&state);
	expand_tokens(head, env, data->local_vars);
	return (head);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 18:52:32 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:32:30 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "global_vars.h"
#include "minishell.h"

volatile sig_atomic_t	g_exit_status = 0;

t_data	*init_minishell(char **envp)
{
	t_data	*data;
	char	cwd[PATH_MAX];

	data = malloc(sizeof(t_data));
	if (!data)
	{
		perror("malloc");
		exit(1);
	}
	data->env = env_init(envp);
	if (!data->env)
	{
		if (getcwd(cwd, sizeof(cwd)))
			env_set(&(data->env), "PWD", cwd);
		env_set(&(data->env), "SHLVL", "1");
		env_set(&(data->env), "_", "./minishell");
		env_set(&(data->env), "PATH", "/usr/bin:/bin");
	}
	data->local_vars = NULL;
	data->exit_status = 0;
	data->input = NULL;
	data->tokens = NULL;
	data->cmdlist = NULL;
	return (data);
}

void	set_minishell_signals(void)
{
	rl_catch_signals = 0;
	signal(SIGINT, handle_sigint);
	signal(SIGQUIT, handle_sigquit);
}

void	process_input(t_data *data)
{
	char	*line;

	while (1)
	{
		line = readline("minishell$> ");
		if (line == NULL && g_exit_status == 130)
		{
			g_exit_status = 0;
			continue ;
		}
		if (line == NULL)
			break ;
		if (line[0] == '\0')
		{
			free(line);
			continue ;
		}
		add_history(line);
		data->input = line;
		process_line(data);
	}
}

int	clean_minishell(t_data *data)
{
	int	exit_status;

	ft_putendl_fd("exit", 2);
	rl_clear_history();
	free_env(data->env);
	exit_status = data->exit_status;
	free(data);
	return (exit_status);
}

int	main(int argc, char **argv, char **envp)
{
	t_data	*data;
	int		exit_status;

	(void)argc;
	(void)argv;
	data = init_minishell(envp);
	set_minishell_signals();
	process_input(data);
	exit_status = clean_minishell(data);
	return (exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 14:47:37 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 19:58:36 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_cmdlist	*create_cmdlist_node(t_token **tokens)
{
	t_cmdlist	*node;

	node = malloc(sizeof(t_cmdlist));
	if (!node)
	{
		perror("malloc");
		return (NULL);
	}
	node->andor = parse_andor(tokens);
	if (!node->andor)
	{
		free(node);
		return (NULL);
	}
	node->next = NULL;
	return (node);
}

void	append_node(t_cmdlist **head, t_cmdlist **tail, t_cmdlist *node)
{
	if (*head == NULL)
	{
		*head = node;
		*tail = node;
	}
	else
	{
		(*tail)->next = node;
		*tail = node;
	}
}

bool	_validate_token_after_andor(t_token **current_token_ptr_ptr)
{
	if (*current_token_ptr_ptr && (*current_token_ptr_ptr)->type == SEMICOLON)
	{
		*current_token_ptr_ptr = (*current_token_ptr_ptr)->next;
		if (*current_token_ptr_ptr
			&& (*current_token_ptr_ptr)->type == SEMICOLON)
		{
			ft_putendl_fd("minishell: syntax error near unexpected token `;;'",
				2);
			return (false);
		}
	}
	else if (*current_token_ptr_ptr)
	{
		ft_putendl_fd("minishell: syntax error", 2);
		return (false);
	}
	return (true);
}

bool	_parse_and_append_cmdlist_node(t_cmdlist **head_ptr,
		t_cmdlist **tail_ptr, t_token **current_token_ptr_ptr)
{
	t_cmdlist	*node;

	node = create_cmdlist_node(current_token_ptr_ptr);
	if (!node)
	{
		return (false);
	}
	append_node(head_ptr, tail_ptr, node);
	if (!_validate_token_after_andor(current_token_ptr_ptr))
	{
		return (false);
	}
	return (true);
}

t_cmdlist	*parse_line(t_token *tokens)
{
	t_token		*current_token_ptr;
	t_cmdlist	*head;
	t_cmdlist	*tail;

	head = NULL;
	tail = NULL;
	current_token_ptr = tokens;
	if (!current_token_ptr)
		return (NULL);
	while (current_token_ptr)
	{
		if (!_parse_and_append_cmdlist_node(&head, &tail, &current_token_ptr))
		{
			free_cmdlist(head);
			return (NULL);
		}
	}
	return (head);
}

t_command	*_init_regular_command_struct(size_t *argc_ptr,
		size_t *capacity_ptr)
{
	t_command	*cmd;

	*argc_ptr = 0;
	*capacity_ptr = 0;
	cmd = init_command();
	if (!cmd)
		return (NULL);
	if (init_cmd_args(cmd, capacity_ptr, argc_ptr) == -1)
	{
		free_command(cmd);
		return (NULL);
	}
	return (cmd);
}

bool	_populate_and_finalize_command(t_command *cmd, t_token **cur,
		size_t *argc_ptr, size_t *capacity_ptr)
{
	collect_cmd_args(cmd, cur, argc_ptr, capacity_ptr);
	if (*argc_ptr == 0 && cmd->redirs == NULL && cmd->output == NULL
		&& cmd->input == NULL)
	{
		return (false);
	}
	if (cmd->args)
		cmd->args[*argc_ptr] = NULL;
	return (true);
}

t_command	*parse_regular_command(t_token **cur)
{
	t_command	*cmd;
	size_t		argc;
	size_t		capacity;

	if (!*cur || ((*cur)->type != WORD && !is_redirection(*cur)))
		return (NULL);
	cmd = _init_regular_command_struct(&argc, &capacity);
	if (!cmd)
		return (NULL);
	if (!_populate_and_finalize_command(cmd, cur, &argc, &capacity))
	{
		free_command(cmd);
		return (NULL);
	}
	return (cmd);
}

t_command	*parse_subshell_command(t_token **cur)
{
	t_command	*cmd;
	size_t		argc;
	size_t		capacity;

	cmd = parse_subshell(cur);
	if (!cmd)
		return (NULL);
	if (init_cmd_args(cmd, &capacity, &argc) == -1)
	{
		free_command(cmd);
		return (NULL);
	}
	collect_cmd_args(cmd, cur, &argc, &capacity);
	if (cmd->args)
		cmd->args[argc] = NULL;
	return (cmd);
}

t_command	*parse_command(t_token **cur)
{
	if (!cur || !*cur)
		return (NULL);
	if ((*cur)->type == PAREN_OPEN)
		return (parse_subshell_command(cur));
	else
		return (parse_regular_command(cur));
}

t_token	*collect_and_validate_subshell_tokens(t_token **cur)
{
	t_token	*sub_tokens_head;

	if (!skip_opening_paren(cur))
	{
		ft_putendl_fd("minishell: syntax error near unexpected token `('", 2);
		return (NULL);
	}
	sub_tokens_head = collect_tokens_until_closing(cur);
	if (!sub_tokens_head)
	{
		return (NULL);
	}
	return (sub_tokens_head);
}

t_cmdlist	*parse_subshell_tokens(t_token *sub_tokens_head)
{
	t_cmdlist	*sub_ast;

	sub_ast = parse_line(sub_tokens_head);
	free_tokens(sub_tokens_head);
	if (!sub_ast)
	{
		ft_putendl_fd("minishell: error parsing subshell content", 2);
		return (NULL);
	}
	return (sub_ast);
}

t_command	*parse_subshell(t_token **cur)
{
	t_token		*sub_tokens_head;
	t_cmdlist	*sub_ast;
	t_command	*cmd;

	sub_tokens_head = collect_and_validate_subshell_tokens(cur);
	if (!sub_tokens_head)
	{
		return (NULL);
	}
	sub_ast = parse_subshell_tokens(sub_tokens_head);
	if (!sub_ast)
	{
		return (NULL);
	}
	cmd = create_subshell_command(sub_ast);
	if (!cmd)
	{
		free_cmdlist(sub_ast);
		return (NULL);
	}
	return (cmd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipeline_and_glob_utils.c                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 16:46:08 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 20:03:38 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*read_heredoc(const char *delim, bool quoted)
{
	size_t	cap;
	size_t	len;
	char	*content;

	(void)quoted;
	cap = 1024;
	len = 0;
	content = malloc(cap);
	if (!content)
		exit(1);
	content[0] = '\0';
	while (!process_heredoc_line(delim, &content, &len, &cap))
		;
	return (content);
}

static bool	_link_pipeline_commands(t_command **current_ptr, t_token **cur,
		t_command *first_for_cleanup)
{
	t_command	*next_cmd;

	while (*cur && ((*cur)->type == PIPE))
	{
		*cur = (*cur)->next;
		if (!*cur)
		{
			free_command(first_for_cleanup);
			return (false);
		}
		next_cmd = parse_command(cur);
		if (!next_cmd)
		{
			free_command(first_for_cleanup);
			return (false);
		}
		(*current_ptr)->next_pipe = next_cmd;
		*current_ptr = next_cmd;
	}
	return (true);
}

t_command	*parse_pipeline(t_token **cur)
{
	t_command	*first;
	t_command	*current;

	first = parse_command(cur);
	if (!first)
		return (NULL);
	current = first;
	if (!_link_pipeline_commands(&current, cur, first))
	{
		return (NULL);
	}
	return (first);
}

void	get_dir_and_pattern(const char *pattern, char *dirpath, size_t size,
		const char **pat)
{
	const char	*slash;
	size_t		len;

	slash = strrchr(pattern, '/');
	if (slash)
	{
		len = slash - pattern;
		if (len < size)
		{
			ft_strncpy(dirpath, pattern, len);
			dirpath[len] = '\0';
		}
		else
		{
			ft_strncpy(dirpath, ".", size);
			dirpath[size - 1] = '\0';
		}
		*pat = slash + 1;
	}
	else
	{
		ft_strncpy(dirpath, ".", size);
		dirpath[size - 1] = '\0';
		*pat = pattern;
	}
}

char	**read_directory_matches(const char *dirpath, const char *pat)
{
	t_globinfo	info;

	info.dir = opendir(dirpath);
	if (!info.dir)
		return (NULL);
	info.capacity = 8;
	info.count = 0;
	info.matches = malloc(info.capacity * sizeof(char *));
	if (!info.matches)
	{
		closedir(info.dir);
		return (NULL);
	}
	if (process_directory_entries(&info, dirpath, pat) == -1)
	{
		closedir(info.dir);
		free(info.matches);
		return (NULL);
	}
	closedir(info.dir);
	return (finalize_matches(info.matches, info.count));
}

void	ensure_content_capacity(char **content_ptr, size_t current_len,
		size_t *cap_ptr, size_t line_len)
{
	size_t	required_cap;
	size_t	old_size;
	size_t	new_cap;
	char	*tmp;

	required_cap = current_len + line_len + 2;
	if (required_cap > *cap_ptr)
	{
		old_size = *cap_ptr;
		new_cap = *cap_ptr + line_len + 1024;
		tmp = ft_realloc(*content_ptr, old_size, new_cap);
		if (!tmp)
		{
			perror("minishell: ft_realloc in append_line");
			free(*content_ptr);
			*content_ptr = NULL;
			exit(1);
		}
		*content_ptr = tmp;
		*cap_ptr = new_cap;
	}
}

void	append_line(char **content, size_t *len, size_t *cap, const char *line)
{
	size_t	l_len;

	if (!content || !line)
	{
		return ;
	}
	l_len = ft_strlen(line);
	ensure_content_capacity(content, *len, cap, l_len);
	if (!*content)
	{
		return ;
	}
	ft_memcpy(*content + *len, line, l_len);
	*len += l_len;
	(*content)[(*len)++] = '\n';
	(*content)[*len] = '\0';
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 23:29:58 by michel            #+#    #+#             */
/*   Updated: 2025/04/26 17:33:22 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_input_redirection(t_command *cmd)
{
	int	fd;

	if (!cmd->input)
		return (0);
	fd = open(cmd->input, O_RDONLY);
	if (fd < 0)
	{
		perror("minishell: open input");
		return (-1);
	}
	if (dup2(fd, STDIN_FILENO) < 0)
	{
		perror("minishell: dup2 input");
		close(fd);
		return (-1);
	}
	close(fd);
	return (0);
}

int	handle_output_trunc_redirection(t_command *cmd)
{
	int	fd;

	if (!cmd->output)
		return (0);
	fd = open(cmd->output, O_WRONLY | O_CREAT | O_TRUNC, 0644);
	if (fd < 0)
	{
		perror("minishell: open output");
		return (-1);
	}
	if (dup2(fd, STDOUT_FILENO) < 0)
	{
		perror("minishell: dup2 output");
		close(fd);
		return (-1);
	}
	close(fd);
	return (0);
}

int	handle_output_append_redirection(t_command *cmd)
{
	int	fd;

	if (!cmd->output)
		return (0);
	fd = open(cmd->output, O_WRONLY | O_CREAT | O_APPEND, 0644);
	if (fd < 0)
	{
		perror("minishell: open output (append)");
		return (-1);
	}
	if (dup2(fd, STDOUT_FILENO) < 0)
	{
		perror("minishell: dup2 output (append)");
		close(fd);
		return (-1);
	}
	close(fd);
	return (0);
}

int	handle_heredoc(t_command *cmd)
{
	int		fd;
	char	*tmp_name;
	int		ret;

	fd = open_tmp_heredoc_file(&tmp_name);
	if (fd < 0)
	{
		perror("open heredoc");
		return (-1);
	}
	ret = read_and_write_heredoc(fd, cmd->input);
	if (ret < 0)
	{
		close(fd);
		unlink(tmp_name);
		free(tmp_name);
		return (-1);
	}
	ret = finalize_heredoc(fd, tmp_name);
	return (ret);
}

int	handle_redirection(t_command *cmd)
{
	int	ret;

	if (cmd->heredoc)
	{
		ret = handle_heredoc(cmd);
		if (ret < 0)
			return (ret);
	}
	else if (cmd->input)
	{
		ret = handle_input_redirection(cmd);
		if (ret < 0)
			return (ret);
	}
	if (cmd->output)
	{
		if (cmd->append)
			ret = handle_output_append_redirection(cmd);
		else
			ret = handle_output_trunc_redirection(cmd);
		if (ret < 0)
			return (ret);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   subshell_exec_utils.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 15:34:47 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 20:16:08 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool	skip_opening_paren(t_token **cur)
{
	if (!cur || !*cur || (*cur)->type != PAREN_OPEN)
		return (false);
	*cur = (*cur)->next;
	return (true);
}

t_token	*duplicate_original_token(t_token *original)
{
	t_token	*extracted_token;

	extracted_token = allocate_token();
	if (!extracted_token)
		return (NULL);
	initialize_token(extracted_token, original->value);
	if (!extracted_token->value && original->value)
	{
		free(extracted_token);
		return (NULL);
	}
	extracted_token->quoted = original->quoted;
	extracted_token->next = NULL;
	return (extracted_token);
}

bool	should_break_subshell_loop(t_token *token, int *balance)
{
	if (token->type == PAREN_OPEN)
	{
		(*balance)++;
	}
	else if (token->type == PAREN_CLOSE)
	{
		(*balance)--;
		if (*balance == 0)
			return (true);
	}
	if (*balance < 0)
		return (true);
	return (false);
}

t_token	*finalize_subshell_collection(t_token *head, t_token **cur,
		t_token *current_original, int balance)
{
	if (balance != 0)
	{
		ft_putendl_fd("minishell: syntax error: unclosed parenthesis", 2);
		free_tokens(head);
		return (NULL);
	}
	if (current_original)
		*cur = current_original->next;
	else
		*cur = NULL;
	return (head);
}

t_token	*process_subshell_tokens_loop(t_token **cur, int *balance_ptr,
		t_token **head_ptr, t_token **tail_ptr)
{
	t_token	*current_original;
	t_token	*extracted_token;

	current_original = *cur;
	while (current_original)
	{
		if (should_break_subshell_loop(current_original, balance_ptr))
			break ;
		extracted_token = duplicate_original_token(current_original);
		if (!extracted_token)
		{
			free_tokens(*head_ptr);
			return (NULL);
		}
		append_token_to_list(head_ptr, tail_ptr, extracted_token);
		current_original = current_original->next;
	}
	return (current_original);
}

t_token	*collect_tokens_until_closing(t_token **cur)
{
	t_token	*head;
	t_token	*tail;
	t_token	*last_processed;
	int		balance;

	head = NULL;
	tail = NULL;
	if (!cur || !*cur)
		return (NULL);
	balance = 1;
	last_processed = process_subshell_tokens_loop(cur, &balance, &head, &tail);
	if (!head && balance == 1 && !last_processed)
	{
		return (NULL);
	}
	return (finalize_subshell_collection(head, cur, last_processed, balance));
}

char	**glob_pattern(const char *pattern)
{
	char		dirpath[PATH_MAX];
	const char	*pat;

	if (!pattern)
		return (NULL);
	get_dir_and_pattern(pattern, dirpath, sizeof(dirpath), &pat);
	return (read_directory_matches(dirpath, pat));
}

void	_free_str_array_child(char **array)
{
	int	i;

	if (!array)
		return ;
	i = 0;
	while (array[i])
	{
		free(array[i]);
		i++;
	}
	free(array);
}

void	_child_process_exec(char *exec_path, t_command *cmd, t_data *data)
{
	char	**env_array;

	if (handle_redirection(cmd) < 0)
		exit(1);
	env_array = env_to_array(data->env);
	if (!env_array)
		exit(1);
	execve(exec_path, cmd->args, env_array);
	perror("minishell: execve");
	_free_str_array_child(env_array);
	exit(126);
}

int	_parent_process_wait(pid_t pid)
{
	int	status;

	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	if (WIFSIGNALED(status))
		return (128 + WTERMSIG(status));
	return (1);
}

int	fork_and_execute(char *exec_path, t_command *cmd, t_data *data)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		perror("minishell: fork");
		return (1);
	}
	if (pid == 0)
	{
		_child_process_exec(exec_path, cmd, data);
	}
	return (_parent_process_wait(pid));
}

void	_child_process_exec_no_redir(char *exec_path, t_command *cmd,
		t_data *data)
{
	char	**env_array;

	env_array = env_to_array(data->env);
	if (!env_array)
		exit(1);
	execve(exec_path, cmd->args, env_array);
	perror("minishell: execve");
	_free_str_array_child(env_array);
	exit(126);
}

int	fork_and_execute_no_redir(char *exec_path, t_command *cmd, t_data *data)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		perror("minishell: fork");
		return (1);
	}
	if (pid == 0)
	{
		_child_process_exec_no_redir(exec_path, cmd, data);
	}
	return (_parent_process_wait(pid));
}

void	skip_semicolon(t_token **tokens)
{
	if (*tokens && (*tokens)->type == SEMICOLON)
		*tokens = (*tokens)->next;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 18:19:06 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:33:31 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool	validate_tokens(t_token *tokens)
{
	int		paren_balance;
	t_token	*cur;
	bool	prev_was_operator;

	paren_balance = 0;
	cur = tokens;
	prev_was_operator = false;
	while (cur)
	{
		if (!update_paren(cur, &paren_balance))
			return (false);
		if (!validate_redirection(cur))
			return (false);
		if (!update_operator(cur, &prev_was_operator))
			return (false);
		cur = cur->next;
	}
	return (paren_balance == 0);
}

bool	check_redirection(t_token *cur)
{
	if (cur->type == REDIR_IN || cur->type == REDIR_OUT
		|| cur->type == REDIR_APPEND || cur->type == HEREDOC)
	{
		if (!cur->next || cur->next->type != WORD)
			return (false);
	}
	return (true);
}

bool	validate_tokens_adv(t_token *tokens)
{
	t_token	*prev;
	t_token	*cur;

	if (!tokens)
		return (false);
	if (is_operator(tokens))
		return (false);
	prev = tokens;
	cur = tokens->next;
	while (cur)
	{
		if (adjacent_operators(prev, cur))
			return (false);
		if (!check_redirection(cur))
			return (false);
		prev = cur;
		cur = cur->next;
	}
	if (is_operator(prev))
		return (false);
	return (true);
}

void	*ft_realloc(void *ptr, size_t old_size, size_t new_size)
{
	void	*new_ptr;

	if (!ptr)
		return (malloc(new_size));
	if (new_size == 0)
	{
		free(ptr);
		return (NULL);
	}
	new_ptr = malloc(new_size);
	if (!new_ptr)
		return (NULL);
	if (old_size > 0)
	{
		if (new_size < old_size)
			old_size = new_size;
		ft_memcpy(new_ptr, ptr, old_size);
	}
	free(ptr);
	return (new_ptr);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   uitls_builting.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/26 18:35:30 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 20:14:26 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_export_arguments(char **args, t_data *data)
{
	int	i;

	i = 1;
	while (args[i])
	{
		if (process_export_argument(args[i], data))
			return (1);
		i++;
	}
	return (0);
}

static bool	_extract_export_kv(char *arg, t_export_kv *kv)
{
	kv->eq = ft_strchr(arg, '=');
	if (kv->eq)
	{
		kv->key = extract_key(arg, kv->eq);
		kv->raw_value = extract_value(kv->eq);
	}
	else
	{
		kv->key = ft_strdup(arg);
		kv->raw_value = NULL;
	}
	if (!kv->key)
	{
		perror("minishell: strdup/substr failed for export key");
		free(kv->raw_value);
		return (false);
	}
	return (true);
}

static bool	_validate_export_key(const char *key, char *arg_for_error)
{
	if (!is_valid_identifier(key))
	{
		ft_putstr_fd("minishell: export: `", 2);
		ft_putstr_fd(arg_for_error, 2);
		ft_putstr_fd("': not a valid identifier\n", 2);
		return (false);
	}
	return (true);
}

static int	_update_or_add_env_var(t_data *data, char *key, char *final_value)
{
	if (update_env_var(data, key, final_value))
	{
		free(key);
		free(final_value);
	}
	else
	{
		if (add_env_var(data, key, final_value))
		{
			return (1);
		}
	}
	return (0);
}

static int	_process_and_update_env(t_data *data, t_export_kv *kv)
{
	char	*final_value;

	if (!kv->eq || !kv->raw_value)
	{
		free(kv->key);
		free(kv->raw_value);
		return (0);
	}
	final_value = interpret_raw_value(kv->raw_value);
	free(kv->raw_value);
	kv->raw_value = NULL;
	if (!final_value)
	{
		perror("minishell: interpret_raw_value failed for export value");
		free(kv->key);
		return (1);
	}
	return (_update_or_add_env_var(data, kv->key, final_value));
}

int	process_export_argument(char *arg, t_data *data)
{
	t_export_kv	kv;

	kv.key = NULL;
	kv.raw_value = NULL;
	if (!_extract_export_kv(arg, &kv))
		return (1);
	if (!_validate_export_key(kv.key, arg))
	{
		free(kv.key);
		free(kv.raw_value);
		return (1);
	}
	return (_process_and_update_env(data, &kv));
}

char	*extract_key(char *arg, char *eq)
{
	size_t	key_len;

	key_len = eq - arg;
	return (ft_substr(arg, 0, key_len));
}

char	*extract_value(char *eq)
{
	return (ft_strdup(eq + 1));
}

void	unset_env_variable(t_env **env, char *key)
{
	t_env	*node;
	t_env	*prev;

	node = *env;
	prev = NULL;
	while (node)
	{
		if (ft_strcmp(node->key, key) == 0)
		{
			if (prev)
				prev->next = node->next;
			else
				*env = node->next;
			free_env_variable(node);
			return ;
		}
		prev = node;
		node = node->next;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 17:34:08 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/25 13:19:16 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*ft_strtok(char *s, const char *delim)
{
	static char	*static_str;
	char		*token;

	if (s)
		static_str = s;
	if (!static_str || !delim)
		return (NULL);
	while (*static_str && ft_strchr(delim, *static_str))
		static_str++;
	if (!*static_str)
	{
		static_str = NULL;
		return (NULL);
	}
	token = static_str;
	while (*static_str && !ft_strchr(delim, *static_str))
		static_str++;
	if (*static_str)
	{
		*static_str = '\0';
		static_str++;
	}
	return (token);
}

int	ft_strcmp(const char *s1, const char *s2)
{
	int	i;

	i = 0;
	while (s1[i] || s2[i])
	{
		if (s1[i] != s2[i])
			return (s1[i] - s2[i]);
		i++;
	}
	return (s1[i] - s2[i]);
}

int	find_env_index(char **env, char *var)
{
	int		i;
	size_t	key_len;
	char	*eq;

	i = 0;
	eq = ft_strchr(var, '=');
	if (!eq)
		return (-1);
	key_len = eq - var;
	while (env[i])
	{
		if (!ft_strncmp(env[i], var, key_len) && env[i][key_len] == '=')
			return (i);
		i++;
	}
	return (-1);
}

char	**add_env_variable(char **env, char *new_var)
{
	int		cnt;
	int		i;
	char	**new_env;

	cnt = 0;
	while (env[cnt])
		cnt++;
	new_env = malloc((cnt + 2) * sizeof(char *));
	if (!new_env)
		return (NULL);
	i = 0;
	while (i < cnt)
	{
		new_env[i] = env[i];
		i++;
	}
	new_env[i] = ft_strdup(new_var);
	new_env[i + 1] = NULL;
	free(env);
	return (new_env);
}

int	find_env_index_unset(char **env, char *var)
{
	int	i;
	int	len;

	i = 0;
	len = ft_strlen(var);
	while (env[i])
	{
		if (!ft_strncmp(env[i], var, len) && env[i][len] == '=')
			return (i);
		i++;
	}
	return (-1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 17:24:30 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 20:04:30 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool	match_pattern(const char *pattern, const char *str)
{
	size_t	skip;

	if (!*pattern)
		return (!*str);
	if (*pattern == '*')
	{
		skip = 0;
		while (true)
		{
			if (match_pattern(pattern + 1, str + skip))
				return (true);
			if (!str[skip])
				break ;
			skip++;
		}
		return (false);
	}
	return ((*pattern == *str) && match_pattern(pattern + 1, str + 1));
}

bool	is_redirection(t_token *token)
{
	if (!token)
		return (false);
	return (token->type == REDIR_IN || token->type == REDIR_OUT
		|| token->type == REDIR_APPEND || token->type == HEREDOC);
}

void	free_env(t_env *env)
{
	t_env	*tmp;

	while (env)
	{
		tmp = env->next;
		free(env->key);
		free(env->value);
		free(env);
		env = tmp;
	}
}

bool	ensure_globinfo_capacity(t_globinfo *info)
{
	char	**tmp;
	size_t	old_size;
	size_t	new_capacity;
	size_t	new_size_bytes;

	if (info->count >= info->capacity)
	{
		old_size = info->capacity * sizeof(char *);
		new_capacity = info->capacity * 2;
		if (new_capacity == 0)
			new_capacity = 8;
		new_size_bytes = new_capacity * sizeof(char *);
		tmp = ft_realloc(info->matches, old_size, new_size_bytes);
		if (!tmp)
		{
			perror("minishell: ft_realloc in add_match");
			return (false);
		}
		info->matches = tmp;
		info->capacity = new_capacity;
	}
	return (true);
}

int	add_match(t_globinfo *info, const char *dirpath, const char *filename)
{
	char	*fullpath;

	if (!ensure_globinfo_capacity(info))
	{
		return (-1);
	}
	fullpath = build_fullpath(dirpath, filename);
	if (!fullpath)
	{
		perror("minishell: build_fullpath in add_match");
		return (0);
	}
	info->matches[info->count] = fullpath;
	info->count++;
	info->matches[info->count] = NULL;
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 20:58:02 by michel            #+#    #+#             */
/*   Updated: 2025/04/26 17:35:16 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "global_vars.h"
#include "minishell.h"

char	*build_fullpath(const char *dirpath, const char *filename)
{
	size_t	len_dir;
	size_t	len_file;
	char	*fullpath;

	if (ft_strcmp(dirpath, ".") == 0)
		return (ft_strdup(filename));
	len_dir = ft_strlen(dirpath);
	len_file = ft_strlen(filename);
	fullpath = malloc(len_dir + 1 + len_file + 1);
	if (!fullpath)
		return (NULL);
	ft_strcpy(fullpath, dirpath);
	fullpath[len_dir] = '/';
	ft_strcpy(fullpath + len_dir + 1, filename);
	return (fullpath);
}

char	*ft_strcpy(char *dest, const char *src)
{
	int	i;

	i = 0;
	while (src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = '\0';
	return (dest);
}

void	handle_sigint(int sig)
{
	(void)sig;
	g_exit_status = 130;
	rl_replace_line("", 0);
	rl_done = 1;
	write(STDOUT_FILENO, "\n", 1);
}

void	handle_sigquit(int sig)
{
	(void)sig;
}

void	free_tokens(t_token *tokens)
{
	t_token	*tmp;

	while (tokens)
	{
		tmp = tokens->next;
		if (tokens->value)
			free(tokens->value);
		free(tokens);
		tokens = tmp;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_env.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:07:18 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 20:19:20 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	env_unset(t_env **env, const char *key)
{
	t_env	*node;
	t_env	*prev;
	size_t	key_len;

	node = *env;
	prev = NULL;
	key_len = ft_strlen(key);
	while (node)
	{
		if (ft_strncmp(node->key, key, key_len) == 0
			&& node->key[key_len] == '\0')
		{
			if (prev)
				prev->next = node->next;
			else
				*env = node->next;
			free(node->key);
			free(node->value);
			free(node);
			return ;
		}
		prev = node;
		node = node->next;
	}
}

int	count_env_variables(t_env *env)
{
	t_env	*node;
	int		count;

	count = 0;
	node = env;
	while (node)
	{
		count++;
		node = node->next;
	}
	return (count);
}

char	**allocate_env_array(int count)
{
	char	**array;

	array = malloc((count + 1) * sizeof(char *));
	if (!array)
	{
		perror("minishell: malloc (allocate_env_array)");
		return (NULL);
	}
	return (array);
}

static char	*_format_env_node_to_string(t_env *node)
{
	char	*entry_str;
	size_t	key_len;
	size_t	val_len;
	size_t	total_len;

	key_len = ft_strlen(node->key);
	val_len = ft_strlen(node->value);
	total_len = key_len + 1 + val_len;
	entry_str = malloc(total_len + 1);
	if (!entry_str)
	{
		perror("minishell: malloc (_format_env_node_to_string)");
		return (NULL);
	}
	ft_memcpy(entry_str, node->key, key_len);
	entry_str[key_len] = '=';
	ft_memcpy(entry_str + key_len + 1, node->value, val_len);
	entry_str[total_len] = '\0';
	return (entry_str);
}

void	convert_env_list_to_array(t_env *env, char **array)
{
	int		i;
	t_env	*node;

	i = 0;
	node = env;
	while (node)
	{
		if (!node->key || !node->value)
		{
			node = node->next;
			continue ;
		}
		array[i] = _format_env_node_to_string(node);
		if (!array[i])
		{
			return ;
		}
		i++;
		node = node->next;
	}
	array[i] = NULL;
}

char	**env_to_array(t_env *env)
{
	int		count;
	char	**array;

	count = count_env_variables(env);
	array = allocate_env_array(count);
	if (!array)
		return (NULL);
	convert_env_list_to_array(env, array);
	return (array);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_env2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:50:12 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:33:51 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_env	*find_env_node(t_env *head, const char *key)
{
	size_t	key_len;

	key_len = ft_strlen(key);
	while (head)
	{
		if (ft_strncmp(head->key, key, key_len) == 0
			&& head->key[key_len] == '\0')
			return (head);
		head = head->next;
	}
	return (NULL);
}

void	update_node_value(t_env *node, const char *val)
{
	free(node->value);
	node->value = ft_strdup(val);
}

t_env	*create_env_node2(const char *key, const char *val)
{
	t_env	*node;

	node = malloc(sizeof(t_env));
	if (!node)
	{
		perror("malloc");
		return (NULL);
	}
	node->key = ft_strdup(key);
	node->value = ft_strdup(val);
	node->next = NULL;
	return (node);
}

int	init_cmd_args(t_command *cmd, size_t *capacity, size_t *argc)
{
	*capacity = 8;
	*argc = 0;
	cmd->args = malloc(*capacity * sizeof(char *));
	if (!cmd->args)
	{
		perror("malloc init_cmd_args");
		return (-1);
	}
	cmd->args[0] = NULL;
	return (0);
}

void	collect_cmd_args(t_command *cmd, t_token **cur, size_t *argc,
		size_t *capacity)
{
	while (*cur && (((*cur)->type == WORD) || is_redirection(*cur)))
	{
		if ((*cur)->type == WORD)
			handle_word_token(cur, cmd, argc, capacity);
		else
			parse_redirection(cmd, cur);
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_exec.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:12:20 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/27 15:50:23 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*get_path_env(t_env *env)
{
	char	*path_env;

	path_env = env_get(env, "PATH");
	if (!path_env)
		return (NULL);
	return (ft_strdup(path_env));
}

char	*build_executable_path(const char *directory, const char *cmd)
{
	char	*temp;
	char	*full_path;

	temp = ft_strjoin(directory, "/");
	full_path = ft_strjoin(temp, cmd);
	free(temp);
	return (full_path);
}

char	*search_executable_in_paths(char *paths, const char *cmd)
{
	char	*token;
	char	*full_path;

	token = ft_strtok(paths, ":");
	while (token)
	{
		full_path = build_executable_path(token, cmd);
		if (!full_path)
			return (NULL);
		if (access(full_path, X_OK) == 0)
			return (full_path);
		free(full_path);
		token = ft_strtok(NULL, ":");
	}
	return (NULL);
}

int	save_stdin(void)
{
	int	fd;

	fd = dup(STDIN_FILENO);
	if (fd < 0)
		perror("dup");
	return (fd);
}

void	restore_stdin(int saved)
{
	if (dup2(saved, STDIN_FILENO) < 0)
		perror("dup2");
	close(saved);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_lex1.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:16:19 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:34:05 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_token	*allocate_token(void)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		perror("malloc");
	return (token);
}

char	*duplicate_token_value(const char *str)
{
	char	*dup;

	dup = strdup(str);
	if (!dup)
		perror("strdup");
	return (dup);
}

t_token_type	determine_token_type(const char *str)
{
	if (strcmp(str, "|") == 0)
		return (PIPE);
	if (strcmp(str, "&&") == 0)
		return (AND_IF);
	if (strcmp(str, "||") == 0)
		return (OR_IF);
	if (strcmp(str, ";") == 0)
		return (SEMICOLON);
	if (strcmp(str, ">") == 0)
		return (REDIR_OUT);
	if (strcmp(str, "<") == 0)
		return (REDIR_IN);
	if (strcmp(str, ">>") == 0)
		return (REDIR_APPEND);
	if (strcmp(str, "<<") == 0)
		return (HEREDOC);
	if (strcmp(str, "(") == 0)
		return (PAREN_OPEN);
	if (strcmp(str, ")") == 0)
		return (PAREN_CLOSE);
	return (WORD);
}

void	initialize_token(t_token *token, const char *raw_value)
{
	size_t	len;

	token->value = duplicate_token_value(raw_value);
	if (!token->value)
	{
		return ;
	}
	token->type = determine_token_type(token->value);
	token->quoted = false;
	len = ft_strlen(token->value);
	if (len >= 2)
	{
		if ((token->value[0] == '\'' && token->value[len - 1] == '\'')
			|| (token->value[0] == '\"' && token->value[len - 1] == '\"'))
		{
			token->quoted = true;
		}
	}
	token->next = NULL;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_lex2.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:17:42 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 18:07:36 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_token	*create_token(const char *raw_value)
{
	t_token	*token;

	if (!raw_value)
		return (NULL);
	token = allocate_token();
	if (!token)
		return (NULL);
	initialize_token(token, raw_value);
	if (!token->value)
	{
		free(token);
		return (NULL);
	}
	return (token);
}

bool	is_paren(char c)
{
	return (c == '(' || c == ')');
}

char	*check_initial_paren(t_token_state *state)
{
	char	paren_str[2];

	if (!state->in_single && !state->in_double
		&& is_paren(state->input[state->i]))
	{
		paren_str[0] = state->input[state->i];
		paren_str[1] = '\0';
		append_to_buffer(state->buffer, paren_str);
		state->i++;
		state->buffer->str[state->buffer->index] = '\0';
		return (ft_strdup(state->buffer->str));
	}
	return (NULL);
}

bool	should_break_collecting(t_token_state *state)
{
	if (!state->in_single && !state->in_double)
	{
		if (is_whitespace(state->input[state->i]))
			return (true);
		if (is_paren(state->input[state->i]))
			return (true);
		if (handle_special_operators(state))
		{
			if (state->buffer->index == 0)
				return (false);
			else
				return (true);
		}
	}
	return (false);
}

char	*finalize_collected_token(t_token_state *state)
{
	char	*result;

	state->buffer->str[state->buffer->index] = '\0';
	if (state->buffer->index == 0 && state->input
		&& state->input[state->i] == '\0')
	{
		result = ft_strdup("");
		if (!result)
			perror("minishell: ft_strdup (finalize empty)");
		return (result);
	}
	if (state->buffer->index == 0)
	{
		result = ft_strdup("");
		if (!result)
			perror("minishell: ft_strdup (finalize empty 2)");
		return (result);
	}
	result = ft_strdup(state->buffer->str);
	if (!result)
		perror("minishell: ft_strdup (finalize)");
	return (result);
}

char	*collect_token(t_token_state *state, t_data *data)
{
	char	*initial_token;
	size_t	start_index;

	start_index = state->i;
	state->buffer->index = 0;
	state->buffer->str[0] = '\0';
	initial_token = check_initial_paren(state);
	if (initial_token)
		return (initial_token);
	if (handle_special_operators(state))
	{
		if (state->buffer->index > 0)
			return (finalize_collected_token(state));
	}
	state->buffer->index = 0;
	state->buffer->str[0] = '\0';
	state->i = start_index;
	while (state->input && state->input[state->i])
	{
		if (should_break_collecting(state))
			break ;
		process_token_char(state, data->exit_status, data);
	}
	return (finalize_collected_token(state));
}

void	handle_whitespace(t_token_state *state)
{
	if (!state->in_single && !state->in_double
		&& is_whitespace(state->input[state->i]))
		return ;
}

void	handle_quotes(t_token_state *state)
{
	char	c;

	c = state->input[state->i];
	append_to_buffer(state->buffer, (char[]){c, '\0'});
	state->i++;
	if (c == '\'' && !state->in_double)
	{
		state->in_single = !state->in_single;
	}
	else if (c == '\"' && !state->in_single)
	{
		state->in_double = !state->in_double;
	}
}

void	handle_escape_character(t_token_state *state)
{
	append_to_buffer(state->buffer, "\\");
	state->i++;
	if (state->input[state->i])
	{
		append_to_buffer(state->buffer, (char[]){state->input[state->i], '\0'});
		state->i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_lex3.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:19:44 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:34:18 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	handle_dollar_sign(t_token_state *state, int exit_status_UNUSED,
		t_data *data)
{
	(void)exit_status_UNUSED;
	if (state->input[state->i] == '$' && !state->in_single)
	{
		if (state->input[state->i + 1] == '?')
			handle_dollar_question(state->input, &state->i, state->buffer,
				data);
		else
			handle_dollar_variable(state->input, &state->i, state->buffer,
				data);
	}
}

void	process_regular_character(t_token_state *state)
{
	char	c;

	if (!state->input[state->i])
		return ;
	c = state->input[state->i];
	append_to_buffer(state->buffer, (char[]){c, '\0'});
	state->i++;
}

void	process_token_char(t_token_state *state, int exit_status, t_data *data)
{
	char	current_char;

	if (!state->input || !state->input[state->i])
		return ;
	current_char = state->input[state->i];
	if ((current_char == '\'' && !state->in_double) || (current_char == '\"'
			&& !state->in_single))
	{
		handle_quotes(state);
		return ;
	}
	if (current_char == '\\' && !state->in_single)
	{
		handle_escape_character(state);
		return ;
	}
	if (current_char == '$' && !state->in_single)
	{
		handle_dollar_sign(state, exit_status, data);
		return ;
	}
	append_to_buffer(state->buffer, (char[]){current_char, '\0'});
	state->i++;
}

int	is_option_n(const char *str)
{
	int	i;

	if (str[0] != '-')
		return (0);
	i = 1;
	while (str[i])
	{
		if (str[i] != 'n')
			return (0);
		i++;
	}
	return (1);
}

char	*get_first_token(const char *input)
{
	int	i;

	i = 0;
	while (input[i] && input[i] != ' ' && input[i] != '\t')
		i++;
	return (ft_substr(input, 0, i));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_lex4.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 16:47:55 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:34:25 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool	handle_in_redirect(t_token_state *state)
{
	if (state->input[state->i] != '<')
		return (false);
	if (state->input[state->i + 1] != '\0' && state->input[state->i + 1] == '<')
	{
		if (state->buffer->index != 0)
			return (true);
		append_to_buffer(state->buffer, "<<");
		state->i += 2;
		return (true);
	}
	else
	{
		if (state->buffer->index != 0)
			return (true);
		append_to_buffer(state->buffer, "<");
		state->i++;
		return (true);
	}
}

bool	handle_out_redirect(t_token_state *state)
{
	if (state->input[state->i] != '>')
		return (false);
	if (state->input[state->i + 1] != '\0' && state->input[state->i + 1] == '>')
	{
		if (state->buffer->index != 0)
			return (true);
		append_to_buffer(state->buffer, ">>");
		state->i += 2;
		return (true);
	}
	else
	{
		if (state->buffer->index != 0)
			return (true);
		append_to_buffer(state->buffer, ">");
		state->i++;
		return (true);
	}
}

bool	handle_pipe_operator(t_token_state *state)
{
	if (state->input[state->i] != '|')
		return (false);
	if (state->input[state->i + 1] != '\0' && state->input[state->i + 1] == '|')
	{
		if (state->buffer->index != 0)
			return (true);
		append_to_buffer(state->buffer, "||");
		state->i += 2;
		return (true);
	}
	else
	{
		if (state->buffer->index != 0)
			return (true);
		append_to_buffer(state->buffer, "|");
		state->i++;
		return (true);
	}
}

bool	handle_amp_operator(t_token_state *state)
{
	if (state->input[state->i] != '&')
		return (false);
	if (state->input[state->i + 1] != '\0' && state->input[state->i + 1] == '&')
	{
		if (state->buffer->index != 0)
			return (true);
		append_to_buffer(state->buffer, "&&");
		state->i += 2;
		return (true);
	}
	else
	{
		if (state->buffer->index != 0)
			return (true);
		append_to_buffer(state->buffer, "&");
		state->i++;
		return (true);
	}
}

bool	handle_semicolon_operator(t_token_state *state)
{
	if (state->input[state->i] == ';')
	{
		if (state->buffer->index != 0)
			return (true);
		else
		{
			append_to_buffer(state->buffer, ";");
			state->i++;
			return (true);
		}
	}
	return (false);
}

bool	handle_special_operators(t_token_state *state)
{
	if (state->in_single || state->in_double)
		return (false);
	if (handle_in_redirect(state))
		return (true);
	if (handle_out_redirect(state))
		return (true);
	if (handle_pipe_operator(state))
		return (true);
	if (handle_amp_operator(state))
		return (true);
	if (handle_semicolon_operator(state))
		return (true);
	return (false);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_lex5.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 16:21:31 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 20:21:59 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool	is_whitespace(char c)
{
	return (c == ' ' || c == '\t');
}

size_t	skip_whitespace(const char *input, size_t i)
{
	while (input[i] && is_whitespace(input[i]))
		i++;
	return (i);
}

bool	ensure_buffer_capacity(t_buffer *buf, size_t additional_len)
{
	size_t	required_cap;
	size_t	new_cap;
	char	*new_str;

	required_cap = buf->index + additional_len + 1;
	if (required_cap > buf->cap)
	{
		new_cap = buf->cap + additional_len + 1024;
		new_str = ft_realloc(buf->str, buf->cap, new_cap);
		if (!new_str)
		{
			perror("minishell: ft_realloc in append_to_buffer");
			free(buf->str);
			buf->str = NULL;
			buf->cap = 0;
			buf->index = 0;
			return (false);
		}
		buf->str = new_str;
		buf->cap = new_cap;
	}
	return (true);
}

void	append_to_buffer(t_buffer *buf, const char *s)
{
	size_t	len;

	if (!buf || !buf->str || !s)
		return ;
	len = ft_strlen(s);
	if (len == 0)
		return ;
	if (!ensure_buffer_capacity(buf, len))
		return ;
	ft_memcpy(buf->str + buf->index, s, len);
	buf->index += len;
	buf->str[buf->index] = '\0';
}

void	handle_dollar_question(const char *input, size_t *i, t_buffer *buf,
		t_data *data)
{
	char	*num_str;

	(void)input;
	if (!data)
	{
		num_str = ft_strdup("0");
	}
	else
	{
		num_str = ft_itoa(data->exit_status);
	}
	if (!num_str)
	{
		perror("minishell: ft_itoa failed for exit status");
		num_str = ft_strdup("?");
		if (!num_str)
			return ;
	}
	append_to_buffer(buf, num_str);
	free(num_str);
	*i += 2;
}

size_t	_extract_variable_name(const char *input, size_t start,
		char *var_buffer, size_t buffer_size)
{
	size_t	len;

	len = 0;
	while (input[start + len] && (ft_isalnum(input[start + len]) || input[start
			+ len] == '_'))
	{
		len++;
	}
	if (len > 0)
	{
		if (len >= buffer_size)
			len = buffer_size - 1;
		ft_strncpy(var_buffer, input + start, len);
		var_buffer[len] = '\0';
	}
	return (len);
}

char	*_find_variable_value(const char *var_name, t_data *data)
{
	char	*val;

	val = env_get(data->env, var_name);
	if (!val)
	{
		val = env_get(data->local_vars, var_name);
		if (!val)
			val = "";
	}
	return (val);
}

void	handle_dollar_variable(const char *input, size_t *i, t_buffer *buf,
		t_data *data)
{
	size_t	start;
	size_t	var_len;
	char	var_name[256];
	char	*value;

	start = *i + 1;
	var_len = _extract_variable_name(input, start, var_name, sizeof(var_name));
	if (var_len > 0)
	{
		value = _find_variable_value(var_name, data);
		append_to_buffer(buf, value);
		*i = start + var_len;
	}
	else
	{
		append_to_buffer(buf, "$");
		(*i)++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_parser.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 15:03:00 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:34:37 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_cmdlist	*build_subshell_ast(t_token *tokens)
{
	return (parse_line(tokens));
}

t_token	*extract_subshell_tokens(t_token **cur)
{
	if (!skip_opening_paren(cur))
		return (NULL);
	return (collect_tokens_until_closing(cur));
}

t_command	*create_subshell_command(t_cmdlist *sub_ast)
{
	t_command	*cmd;

	cmd = malloc(sizeof(t_command));
	if (!cmd)
	{
		perror("malloc");
		return (NULL);
	}
	cmd->subshell = true;
	cmd->subshell_ast = sub_ast;
	cmd->args = NULL;
	cmd->input = NULL;
	cmd->output = NULL;
	cmd->append = 0;
	cmd->heredoc = 0;
	cmd->redirs = NULL;
	cmd->next_pipe = NULL;
	return (cmd);
}

int	parse_command_arguments(t_command *cmd, t_token **cur)
{
	size_t	capacity;
	size_t	argc;

	if (init_cmd_args(cmd, &capacity, &argc) == -1)
		return (-1);
	collect_cmd_args(cmd, cur, &argc, &capacity);
	if (argc == 0)
	{
		free(cmd->args);
		cmd->args = NULL;
		return (0);
	}
	cmd->args[argc] = NULL;
	return ((int)argc);
}

void	handle_word_token(t_token **cur, t_command *cmd, size_t *argc,
		size_t *capacity)
{
	if (strchr((*cur)->value, '*') && !(*cur)->quoted)
	{
		if (try_expand_glob(cur, cmd, argc, capacity))
			return ;
	}
	add_argument_to_cmd(cmd, (*cur)->value, argc, capacity);
	*cur = (*cur)->next;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_pipe.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 14:09:04 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:34:43 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	create_child_process(t_command *cmd, int i, t_pipe_info *pi, t_data *data)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		perror("fork");
		return (-1);
	}
	if (pid == 0)
		execute_child(cmd, i, pi, data);
	return (pid);
}

void	close_pipeline_pipes(t_pipe_info *pi)
{
	int	i;

	if (pi->pipes)
	{
		i = 0;
		while (i < 2 * (pi->n - 1))
		{
			close(pi->pipes[i]);
			i++;
		}
	}
}

int	wait_for_children(int n)
{
	int	i;
	int	status;
	int	last_status;

	last_status = 0;
	status = 0;
	i = 0;
	while (i < n)
	{
		wait(&status);
		last_status = status;
		i++;
	}
	return (WEXITSTATUS(last_status));
}

int	fork_pipeline(t_command *pipeline, t_pipe_info *pi, t_data *data)
{
	int			i;
	t_command	*cmd;
	pid_t		pid;

	cmd = pipeline;
	i = 0;
	while (cmd)
	{
		pid = create_child_process(cmd, i, pi, data);
		if (pid < 0)
			return (-1);
		cmd = cmd->next_pipe;
		i++;
	}
	close_pipeline_pipes(pi);
	return (wait_for_children(pi->n));
}

int	execute_pipeline(t_command *pipeline, t_data *data)
{
	int			n;
	t_pipe_info	pi;
	int			status;

	n = count_commands(pipeline);
	pi.n = n;
	pi.pipes = create_pipes(n);
	if (n > 1 && !pi.pipes)
		return (-1);
	status = fork_pipeline(pipeline, &pi, data);
	if (pi.pipes)
		free(pi.pipes);
	return (status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_token.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 15:23:46 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/25 15:29:29 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool	update_paren(t_token *cur, int *paren_balance)
{
	if (ft_strcmp(cur->value, "(") == 0)
	{
		(*paren_balance)++;
	}
	else if (ft_strcmp(cur->value, ")") == 0)
	{
		(*paren_balance)--;
		if (*paren_balance < 0)
			return (false);
	}
	return (true);
}

bool	validate_redirection(t_token *cur)
{
	if (cur->type == REDIR_IN || cur->type == REDIR_OUT
		|| cur->type == REDIR_APPEND || cur->type == HEREDOC)
	{
		if (!cur->next || cur->next->type != WORD)
			return (false);
	}
	return (true);
}

bool	update_operator(t_token *cur, bool *prev_operator)
{
	if (cur->type == AND_IF || cur->type == OR_IF)
	{
		if (*prev_operator)
			return (false);
		*prev_operator = true;
	}
	else if (cur->type != SEMICOLON)
	{
		*prev_operator = false;
	}
	return (true);
}

bool	is_operator(t_token *token)
{
	return (token->type == AND_IF || token->type == OR_IF
		|| token->type == PIPE);
}

bool	adjacent_operators(t_token *prev, t_token *cur)
{
	return (is_operator(prev) && is_operator(cur));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils_token_expand.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/27 16:18:27 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 17:34:50 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "global_vars.h"
#include "minishell.h"

void	process_assignement(char *input, t_data *data)
{
	char	*eq;

	eq = ft_strchr(input, '=');
	if (!eq)
		return ;
	*eq = '\0';
	env_set(&(data->env), input, eq + 1);
	*eq = '=';
}

void	expand_token(t_token *token, t_env *env, t_env *local_vars)
{
	char	*var_name;
	char	*val;

	if (token->value[0] == '$')
	{
		var_name = token->value + 1;
		val = env_get(env, var_name);
		if (!val)
			val = env_get(local_vars, var_name);
		free(token->value);
		if (val)
			token->value = ft_strdup(val);
		else
			token->value = ft_strdup("");
	}
}

void	expand_tokens(t_token *tokens, t_env *env, t_env *local_vars)
{
	while (tokens)
	{
		expand_token(tokens, env, local_vars);
		tokens = tokens->next;
	}
}

int	handle_no_command_arguments(t_command *cmd, int saved_stdin,
		int saved_stdout)
{
	if (!cmd->args || !cmd->args[0])
	{
		if (handle_redirection(cmd) < 0)
		{
			close(saved_stdout);
			return (1);
		}
		restore_stdin(saved_stdin);
		if (dup2(saved_stdout, STDOUT_FILENO) < 0)
			perror("dup2 stdout");
		close(saved_stdout);
		return (0);
	}
	return (-1);
}

bool	handle_special_input_cases(t_data *data)
{
	(void)data;
	return (false);
}

bool	lex_and_validate_input(t_data *data)
{
	data->tokens = lexer(data->input, data->env, data);
	if (!data->tokens)
	{
		return (false);
	}
	if (!validate_tokens_adv(data->tokens))
	{
		ft_putendl_fd("Syntaxe invalide.\n", 2);
		free_tokens(data->tokens);
		data->tokens = NULL;
		data->exit_status = 2;
		return (false);
	}
	return (true);
}

void	parse_execute_and_cleanup(t_data *data)
{
	data->cmdlist = parse_line(data->tokens);
	free_tokens(data->tokens);
	data->tokens = NULL;
	if (!data->cmdlist)
		return ;
	data->exit_status = execute_cmdlist(data->cmdlist, data);
	free_cmdlist(data->cmdlist);
	data->cmdlist = NULL;
}

void	process_line(t_data *data)
{
	int	special_case_handled;

	special_case_handled = handle_special_input_cases(data);
	if (special_case_handled)
		return ;
	if (!lex_and_validate_input(data))
	{
		if (data->input)
		{
			free(data->input);
			data->input = NULL;
		}
		return ;
	}
	parse_execute_and_cleanup(data);
	if (data->input)
	{
		free(data->input);
		data->input = NULL;
	}
}

void	print_tokens_debug(t_token *tokens)
{
	printf("--- Tokens ---\n");
	while (tokens)
	{
		printf("Type: %d, Value: [%s]\n", tokens->type, tokens->value);
		tokens = tokens->next;
	}
	printf("--------------\n");
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   global_vars.h                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/04/02 16:36:53 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/04 13:59:02 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef GLOBAL_VARS_H
# define GLOBAL_VARS_H

# include <signal.h>

extern volatile sig_atomic_t	g_exit_status;
#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nicolsan <nicolsan@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 14:30:47 by mm-furi           #+#    #+#             */
/*   Updated: 2025/04/26 20:21:47 by nicolsan         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include "libft/libft.h"
# include <dirent.h>
# include <errno.h>
# include <fcntl.h>
# include <limits.h>
# include <linux/limits.h>
# include <readline/history.h>
# include <readline/readline.h>
# include <signal.h>
# include <stdbool.h>
# include <stddef.h>
# include <stdio.h>
# include <stdlib.h>
# include <string.h>
# include <sys/ioctl.h>
# include <sys/stat.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <term.h>
# include <termios.h>
# include <unistd.h>

typedef struct s_command
{
	char				**args;
	char				*input;
	char				*output;
	int					append;
	int					heredoc;
	bool				subshell;
	struct s_redir		*redirs;
	struct s_command	*next_pipe;
	struct s_cmdlist	*subshell_ast;
}						t_command;

typedef enum e_token_type
{
	WORD,
	PIPE,
	SEMICOLON,
	AND_IF,
	OR_IF,
	REDIR_IN,
	REDIR_OUT,
	REDIR_APPEND,
	HEREDOC,
	PAREN_OPEN,
	PAREN_CLOSE
}						t_token_type;

typedef struct s_redir
{
	t_token_type		type;
	char				*target;
	bool				delim_quoted;
	struct s_redir		*next;
}						t_redir;

typedef struct s_token
{
	char				*value;
	t_token_type		type;
	bool				quoted;
	struct s_token		*next;
}						t_token;

typedef struct s_env
{
	char				*key;
	char				*value;
	struct s_env		*next;
}						t_env;

typedef struct s_buffer
{
	char				*str;
	size_t				index;
	size_t				cap;
}						t_buffer;

typedef struct s_token_state
{
	const char			*input;
	size_t				i;
	bool				in_single;
	bool				in_double;
	t_buffer			*buffer;
}						t_token_state;

typedef struct s_andor
{
	t_command			*pipeline;
	t_token_type		op;
	struct s_andor		*next;
}						t_andor;

typedef struct s_gloinfo
{
	DIR					*dir;
	char				**matches;
	size_t				count;
	size_t				capacity;
	char				*dirpath;
}						t_globinfo;

typedef struct s_cmdlist
{
	t_andor				*andor;
	struct s_cmdlist	*next;
}						t_cmdlist;

typedef struct s_pipe_info
{
	int					n;
	int					*pipes;
}						t_pipe_info;

typedef struct s_data
{
	t_env				*env;
	t_env				*local_vars;
	t_cmdlist			*cmdlist;
	t_token				*tokens;
	t_pipe_info			*pipe;
	t_command			*cmd;
	char				*input;
	int					exit_status;
}						t_data;

typedef struct s_interp_params
{
	char				quote_char;
	size_t				start;
	size_t				end;
	size_t				len;
}						t_interp_params;

typedef struct s_interp_ctx
{
	const char			*raw;
	char				*res;
	size_t				*i_ptr;
	size_t				*res_idx_ptr;
	t_interp_params		params;
}						t_interp_ctx;

typedef struct s_token_list
{
	t_token				*head;
	t_token				*tail;
}						t_token_list;

typedef struct s_export_kv
{
	char				*key;
	char				*raw_value;
	char				*eq;
}						t_export_kv;

char					*ft_strtok(char *s, const char *delim);
char					*find_excutable(const char *cmd, t_env *env);
int						execute_command(t_command *cmd, t_data *data);
int						ft_strcmp(const char *s1, const char *s2);
int						is_builtins(char *cmd);
int						execute_builtin(char **args, t_data *data);
int						builtin_echo(char **args);
int						builtin_pwd(char **args);
int						builtin_export(char **args, t_data *data);
int						builtin_unset(char **args, t_data *data);
int						builtin_env(char **env);
int						builtin_cd(char **args);
int						find_env_index(char **env, char *var);
char					**add_env_variable(char **env, char *new_var);
int						find_env_index_unset(char **env, char *var);
int						handle_input_redirection(t_command *cmd);
int						handle_output_trunc_redirection(t_command *cmd);
int						handle_output_append_redirection(t_command *cmd);
int						handle_heredoc(t_command *cmd);
int						handle_redirection(t_command *cmd);
char					*generate_tmp_name(void);
int						open_tmp_heredoc_file(char **tmp_name);
int						read_and_write_heredoc(int fd, const char *delimiter);
int						finalize_heredoc(int fd, char *tmp_name);
t_token					*create_token(const char *str);
bool					is_whitespace(char c);
size_t					skip_whitespace(const char *input, size_t i);

void					handle_dollar_question(const char *input, size_t *i,
							t_buffer *buf, t_data *data);
void					handle_dollar_variable(const char *input, size_t *i,
							t_buffer *buf, t_data *data);
char					*collect_token(t_token_state *state, t_data *data);
void					process_token_char(t_token_state *state,
							int exit_status, t_data *data);
t_token					*lexer(const char *input, t_env *env, t_data *data);
t_cmdlist				*build_subshell_ast(t_token *tokens);
t_token					*extract_subshell_tokens(t_token **cur);
t_command				*create_subshell_command(t_cmdlist *sub_ast);
int						parse_command_arguments(t_command *cmd, t_token **cur);
void					handle_word_token(t_token **cur, t_command *cmd,
							size_t *argc, size_t *capacity);
void					add_argument_to_cmd(t_command *cmd, const char *arg,
							size_t *argc, size_t *capacity);
void					parse_redirection(t_command *cmd, t_token **cur);
t_andor					*parse_andor(t_token **cur);
void					append_andor(t_andor *head, t_andor *node);
t_andor					*init_andor(t_command *pipeline);
t_command				*init_command(void);
t_cmdlist				*parse_line(t_token *tokens);
bool					skip_opening_paren(t_token **cur);
char					**glob_pattern(const char *pattern);
char					*read_heredoc(const char *delim, bool quoted);
t_command				*parse_pipeline(t_token **cur);
void					get_dir_and_pattern(const char *pattern, char *dirpath,
							size_t size, const char **pat);
char					**read_directory_matches(const char *dirpath,
							const char *pat);
void					append_line(char **content, size_t *len, size_t *cap,
							const char *line);
t_env					*env_init(char **envp);
char					*env_get(t_env *env, const char *key);
void					env_set(t_env **env, const char *key, const char *val);
void					env_unset(t_env **env, const char *key);
char					**env_to_array(t_env *env);
t_token					*collect_tokens_until_closing(t_token **cur);
bool					is_redirection(t_token *token);
t_command				*parse_command(t_token **cur);
t_command				*parse_subshell(t_token **cur);
char					*ft_strncpy(char *dest, const char *src, size_t n);
bool					match_pattern(const char *pattern, const char *str);
int						add_match(t_globinfo *info, const char *dirpath,
							const char *filename);
char					*build_fullpath(const char *dirpath,
							const char *filename);
char					*ft_strcpy(char *dest, const char *src);
void					handle_sigint(int sig);
void					handle_sigquit(int sig);
bool					validate_tokens_adv(t_token *tokens);
void					free_tokens(t_token *tokens);
int						execute_cmdlist(t_cmdlist *commands, t_data *data);
int						execute_andor(t_andor *list, t_data *data);
void					free_cmdlist(t_cmdlist *list);
void					free_andor(t_andor *andor);
void					free_command(t_command *cmd);
void					free_env(t_env *env);
int						count_commands(t_command *pipeline);
int						execute_pipeline(t_command *pipeline, t_data *data);
int						execute_full_command(t_command *cmd, t_data *data);
void					append_to_buffer(t_buffer *buf, const char *s);
void					print_env_array(char **env_array);
t_command				*init_command(void);
int						add_env_var(t_data *data, char *key, char *value);
int						update_env_var(t_data *data, char *key, char *value);
int						execute_builtin_with_redir(t_command *cmd,
							t_data *data);
int						handle_export_arguments(char **args, t_data *data);
int						process_export_argument(char *arg, t_data *data);
char					*extract_key(char *arg, char *eq);
char					*extract_value(char *eq);
int						handle_unset_arguments(char **args, t_data *data);
void					unset_env_variable(t_env **env, char *key);
void					free_env_variable(t_env *node);
t_env					*create_env_node(char *env_entry);
void					add_env_node(t_env **head, t_env *new_node);
int						count_env_variables(t_env *env);
char					**allocate_env_array(int count);
void					convert_env_list_to_array(t_env *env, char **array);
void					setup_pipes_for_child(int index, t_pipe_info *pi);
void					close_unused_pipes(t_pipe_info *pi);
void					execute_builtin_or_command(t_command *cmd,
							t_data *data);
int						is_valid_identifier(const char *str);
int						create_child_process(t_command *cmd, int i,
							t_pipe_info *pi, t_data *data);
void					close_pipeline_pipes(t_pipe_info *pi);
int						wait_for_children(int n);
char					*get_path_env(t_env *env);
char					*build_executable_path(const char *directory,
							const char *cmd);
char					*search_executable_in_paths(char *paths,
							const char *cmd);
int						save_stdin(void);
char					*get_executable_path(t_command *cmd, t_data *data);
int						fork_and_execute(char *exec_path, t_command *cmd,
							t_data *data);
int						fork_and_execute_no_redir(char *exec_path,
							t_command *cmd, t_data *data);
int						execute_external_command(t_command *cmd, t_data *data);
t_token					*allocate_token(void);
char					*duplicate_token_value(const char *str);
t_token_type			determine_token_type(const char *str);
void					initialize_token(t_token *token, const char *str);
void					handle_whitespace(t_token_state *state);
void					handle_quotes(t_token_state *state);
void					handle_escape_character(t_token_state *state);
void					handle_dollar_sign(t_token_state *state,
							int exit_status_UNUSED, t_data *data);
void					process_regular_character(t_token_state *state);
t_token_state			initialize_token_state(const char *input);
void					cleanup_token_state(t_token_state *state);
void					append_token_to_list(t_token **head, t_token **tail,
							t_token *new_token);
t_token					*process_tokens(t_token_state *state, t_data *data);
void					restore_stdin(int saved);
int						save_stdin(void);
t_env					*find_env_node(t_env *head, const char *key);
void					update_node_value(t_env *node, const char *val);
t_env					*create_env_node2(const char *key, const char *val);
int						execute_child(t_command *cmd, int index,
							t_pipe_info *pi, t_data *data);
int						*create_pipes(int n);
void					skip_semicolon(t_token **tokens);
bool					update_paren(t_token *cur, int *paren_balance);
bool					validate_redirection(t_token *cur);
bool					update_operator(t_token *cur, bool *prev_operator);
bool					is_operator(t_token *token);
bool					adjacent_operators(t_token *prev, t_token *cur);
void					add_all_matches_to_cmd(char **matches, t_command *cmd,
							size_t *argc, size_t *capacity);
void					free_matches(char **matches);
bool					try_expand_glob(t_token **cur, t_command *cmd,
							size_t *argc, size_t *capacity);
bool					process_heredoc_line(const char *delim, char **content,
							size_t *len, size_t *cap);
bool					is_valid_entry(struct dirent *entry);
int						process_directory_entries(t_globinfo *info,
							const char *dirpath, const char *pat);
char					**finalize_matches(char **matches, size_t count);
bool					handle_in_redirect(t_token_state *state);
bool					handle_out_redirect(t_token_state *state);
bool					handle_pipe_operator(t_token_state *state);
bool					handle_amp_operator(t_token_state *state);
bool					handle_special_operators(t_token_state *state);
void					free_command_args(t_command *cmd);
void					free_command_redirs(t_command *cmd);
void					free_pipeline(t_command *cmd);
void					*ft_realloc(void *ptr, size_t old_size,
							size_t new_size);
void					process_assignement(char *input, t_data *data);
void					expand_token(t_token *token, t_env *env,
							t_env *local_vars);
void					expand_tokens(t_token *tokens, t_env *env,
							t_env *local_vars);
int						handle_no_command_arguments(t_command *cmd,
							int saved_stdin, int saved_stdout);
void					process_line(t_data *data);
int						init_cmd_args(t_command *cmd, size_t *capacity,
							size_t *argc);
void					collect_cmd_args(t_command *cmd, t_token **cur,
							size_t *argc, size_t *capacity);
int						builtin_exit(char **args, t_data *data);
int						is_option_n(const char *str);
char					*get_first_token(const char *input);
void					local_set(t_env **local, const char *key,
							const char *val);
void					process_local_assignmment(char *input, t_data *data);
int						execute_subshell(t_command *cmd, t_data *data);
t_command				*parse_subshell_command(t_token **cur);
t_command				*parse_regular_command(t_token **cur);
t_cmdlist				*parse_subshell_tokens(t_token *sub_tokens_head);
t_token					*collect_and_validate_subshell_tokens(t_token **cur);
void					child_process_subshell(t_command *cmd, t_data *data);
int						parent_process_subshell(pid_t pid);
char					*check_initial_paren(t_token_state *state);
bool					should_break_collecting(t_token_state *state);
char					*finalize_collected_token(t_token_state *state);
bool					handle_special_input_cases(t_data *data);
bool					lex_and_validate_input(t_data *data);
void					parse_execute_and_cleanup(t_data *data);
bool					ensure_buffer_capacity(t_buffer *buf,
							size_t additional_len);
bool					ensure_args_capacity(t_command *cmd, size_t argc,
							size_t *capacity);
t_token					*duplicate_original_token(t_token *original);
bool					should_break_subshell_loop(t_token *token,
							int *balance);
t_token					*finalize_subshell_collection(t_token *head,
							t_token **cur, t_token *current_original,
							int balance);
t_token					*process_subshell_tokens_loop(t_token **cur,
							int *balance_ptr, t_token **head_ptr,
							t_token **tail_ptr);
void					ensure_content_capacity(char **content_ptr,
							size_t current_len, size_t *cap_ptr,
							size_t line_len);
size_t					get_digit_count(int n);
void					fill_str(char *str, long num, size_t len);
int						is_in_set(char c, const char *set);
size_t					get_actual_length(char const *s, unsigned int start,
							size_t len);
char					*interpret_raw_value(const char *raw_value);

int						compare_env_vars(const void *a, const void *b);
void					free_env_array(char **env_array);

int						handle_export_no_args(t_data *data);
void					_print_export_key_value(const char *env_var,
							const char *equal_sign);
void					print_export_formatted(const char *env_var);
void					_print_export_key_only(const char *env_var);

bool					_save_original_fds(int *saved_stdin_ptr,
							int *saved_stdout_ptr);

void					_get_interp_params(const char *raw_value,
							t_interp_params *params);

void					_restore_original_fds(int saved_stdin,
							int saved_stdout);

void					_process_char_for_interpretation(t_interp_ctx *ctx);

size_t					_interpret_and_copy(char *result, const char *raw_value,
							t_interp_params params);
bool					_handle_redir_output(t_command *cmd,
							const char *target_val, t_token_type type);

bool					_handle_redir_input(t_command *cmd,
							const char *target_val);
bool					_handle_redir_heredoc(t_command *cmd,
							const char *target_val);
bool					_parse_andor_append(t_andor **tail_ptr, t_token **cur);

int						_handle_exec_path_not_found(t_command *cmd,
							int saved_stdin, int saved_stdout);

int						_dispatch_execution(t_command *cmd, t_data *data);
void					_execute_external_in_child(t_command *cmd,
							t_data *data);

void					_free_str_array(char **array);

int						_calculate_exit_code(char **args, int current_status);

void					_qualify_token_quoting(t_token *token,
							t_token_state *state, size_t start_idx);
bool					_handle_empty_raw_token(char *raw_value,
							t_token_state *state, size_t *i_ptr);

bool					_process_token_loop_step(t_token_list *list,
							t_token_state *state, t_data *data, size_t *i_ptr);

bool					_extract_export_kv(char *arg, t_export_kv *kv);
bool					_validate_export_key(const char *key,
							char *arg_for_error);
int						_update_or_add_env_var(t_data *data, char *key,
							char *final_value);
int						_process_and_update_env(t_data *data, t_export_kv *kv);

bool					_process_heredoc_input_line(int fd,
							const char *interpreted_delimiter);

bool					_validate_token_after_andor(t_token **current_token_ptr_ptr);

bool					_parse_and_append_cmdlist_node(t_cmdlist **head_ptr,
							t_cmdlist **tail_ptr,
							t_token **current_token_ptr_ptr);
bool					_validate_token_after_andor(t_token **current_token_ptr_ptr);

bool					_populate_and_finalize_command(t_command *cmd,
							t_token **cur, size_t *argc_ptr,
							size_t *capacity_ptr);

t_command				*_init_regular_command_struct(size_t *argc_ptr,
							size_t *capacity_ptr);
bool					ensure_globinfo_capacity(t_globinfo *info);
void					_free_str_array_child(char **array);
void					_child_process_exec(char *exec_path, t_command *cmd,
							t_data *data);
int						_parent_process_wait(pid_t pid);
void					_child_process_exec_no_redir(char *exec_path,
							t_command *cmd, t_data *data);
							char	*_find_variable_value(const char *var_name, t_data *data);
							size_t	_extract_variable_name(const char *input, size_t start,
								char *var_buffer, size_t buffer_size);

#endif
