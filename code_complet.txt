/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builting2.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 17:36:34 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/18 17:15:52 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	builtin_unset(char **args, t_data *data)
{
	if (!args[1])
		return (0);

	return (handle_unset_arguments(args, data));
}

int	handle_unset_arguments(char **args, t_data *data)
{
	int	i;

	i = 1;
	while (args[i])
	{
		unset_env_variable(&(data->env), args[i]);
		i++;
	}
	return (0);
}

void	unset_env_variable(t_env **env, char *key)
{
	t_env	*node;
	t_env	*prev;

	node = *env;
	prev = NULL;
	while (node)
	{
		if (ft_strcmp(node->key, key) == 0)
		{
			if (prev)
				prev->next = node->next;
			else
				*env = node->next;

			free_env_variable(node);
			return ;
		}
		prev = node;
		node = node->next;
	}
}

void	free_env_variable(t_env *node)
{
	if (!node)
		return ;

	free(node->key);
	free(node->value);
	free(node);
}

int builtin_env(char **env)
{
	int i;

	i = 0;
	while (env[i])
	{
		ft_putstr_fd(env[i], 1);
		ft_putchar_fd('\n', 1);
		i++;
	}
	return (0);
}

int builtin_cd(char **args)
{
	char *path;

	if (!args[1])
	{
		path = getenv("HOME");
		if (!path)
		{
			ft_putstr_fd("cd : HOME not set\n", 2);
			return (1);
		}
	}
	else
		path = args[1];
	if (chdir(path) != 0)
	{
		perror("cd");
		return (1);
	}
	return (0);
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builting.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/07 14:48:15 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/18 17:15:47 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int is_builtins(char *cmd)
{
	return (!ft_strcmp(cmd, "cd")
		|| !ft_strcmp(cmd, "echo")
		|| !ft_strcmp(cmd, "pwd")
		|| !ft_strcmp(cmd, "export")
		|| !ft_strcmp(cmd, "unset")
		|| !ft_strcmp(cmd, "env")
		|| !ft_strcmp(cmd, "exit"));
}

int execute_builtin(char **args, t_data *data)
{
	if (!ft_strcmp(args[0], "cd"))
		return (builtin_cd(args));
	if (!ft_strcmp(args[0], "echo"))
		return (builtin_echo(args));
	if (!ft_strcmp(args[0], "pwd"))
		return (builtin_pwd(args));
	if (!ft_strcmp(args[0], "export"))
		return (builtin_export(args, data));
	if (!ft_strcmp(args[0], "unset"))
		return (builtin_unset(args, data));
	if (!ft_strcmp(args[0], "env"))
		return (builtin_env(env_to_array(data->env)));
	if (!ft_strcmp(args[0], "exit"))
		exit(0);
	return (0);
}

int builtin_echo(char **args)
{
	int i;
	int nline;

	i = 1;
	nline = 1;
	if (args[i] && ft_strcmp(args[i], "-n") == 0)
	{
		nline = 0;
		i++;
	}
	while (args[i])
	{
		ft_putstr_fd(args[i], 1);
		if (args[i + 1])
			ft_putstr_fd(" ", 1);
		i++;
	}
	if (nline)
		ft_putstr_fd("\n", 1);
	return (0);
}

int builtin_pwd(char **args)
{
	char path[4096];

	(void)args;
	if (getcwd(path, sizeof(path)) == NULL)
	{
		perror("pwd");
		return (1);
	}
	ft_putstr_fd(path, 1);
	ft_putchar_fd('\n', 1);
	return (0);
}

int	builtin_export(char **args, t_data *data)
{
	if (!args[1])
		return (builtin_env(env_to_array(data->env)));

	return (handle_export_arguments(args, data));
}

int	handle_export_arguments(char **args, t_data *data)
{
	int	i;

	i = 1;
	while (args[i])
	{
		if (process_export_argument(args[i], data))
			return (1);
		i++;
	}
	return (0);
}

int	process_export_argument(char *arg, t_data *data)
{
	char	*eq;
	char	*value;
	char	*key;

	eq = ft_strchr(arg, '=');
	key = extract_key(arg, eq);
	value = extract_value(eq);
	if (!eq)
		return (0);
	if (!key || !value)
	{
		perror("ft_substr/ft_strdup");
		free(key);
		free(value);
		return (1);
	}
	if (update_env_var(data, key, value))
		free(key);
	else if (add_env_var(data, key, value))
		return (1);

	return (0);
}

char	*extract_key(char *arg, char *eq)
{
	size_t	key_len;

	key_len = eq - arg;
	return (ft_substr(arg, 0, key_len));
}

char	*extract_value(char *eq)
{
	return (ft_strdup(eq + 1));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 18:05:24 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/18 15:32:45 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_env	*create_env_node(char *env_entry)
{
	t_env	*node;
	char	*equal;

	equal = ft_strchr(env_entry, '=');
	if (!equal)
		return (NULL);

	node = malloc(sizeof(t_env));
	if (!node)
	{
		perror("malloc");
		return (NULL);
	}
	node->key = ft_substr(env_entry, 0, equal - env_entry);
	node->value = ft_strdup(equal + 1);
	node->next = NULL;

	return (node);
}

void	add_env_node(t_env **head, t_env *new_node)
{
	if (!new_node)
		return ;
	new_node->next = *head;
	*head = new_node;
}

t_env	*env_init(char **envp)
{
	t_env	*head;
	t_env	*node;
	int		i;

	head = NULL;
	i = 0;

	while (envp[i])
	{
		node = create_env_node(envp[i]);
		add_env_node(&head, node);
		i++;
	}
	return (head);
}

char	*env_get(t_env *env, const char *key)
{
	size_t key_len;

	key_len = ft_strlen(key);
	while (env)
	{
		if (ft_strncmp(env->key, key, key_len) == 0 && env->key[key_len] == '\0')
			return (env->value);
		env = env->next;
	}
	return (NULL);
}

void	env_set(t_env **env, const char *key, const char *val)
{
	t_env *node;
	size_t key_len;

	node = *env;
	key_len = ft_strlen(key);
	while (node)
	{
		if (ft_strncmp(node->key, key, key_len) == 0 && node->key[key_len] == '\0')
		{
			free(node->value);
			node->value = ft_strdup(val);
			return ;
		}
		node = node->next;
	}
	node = malloc(sizeof(t_env));
	if (!node)
	{
		perror("malloc");
		return ;
	}
	node->key = ft_strdup(key);
	node->value = ft_strdup(val);
	node->next = *env;
	*env = node;
}

void	env_unset(t_env **env, const char *key)
{
	t_env *node;
	t_env *prev;
	size_t key_len;

	node = *env;
	prev = NULL;
	key_len = ft_strlen(key);
	while (node)
	{
		if (ft_strncmp(node->key, key, key_len) == 0 && node->key[key_len] == '\0')
		{
			if (prev)
				prev->next = node->next;
			else
				*env = node->next;
			free(node->key);
			free(node->value);
			free(node);
			return ;
		}
		prev = node;
		node = node->next;
	}
}

int	count_env_variables(t_env *env)
{
	t_env	*node;
	int		count;

	count = 0;
	node = env;
	while (node)
	{
		count++;
		node = node->next;
	}
	return (count);
}

char	**allocate_env_array(int count)
{
	char	**array;

	array = malloc((count + 1) * sizeof(char *));
	if (!array)
	{
		perror("malloc");
		return (NULL);
	}
	return (array);
}

void	convert_env_list_to_array(t_env *env, char **array)
{
	int		i;
	t_env	*node;
	char	*tmp;

	i = 0;
	node = env;
	while (node)
	{
		tmp = ft_strjoin(node->key, "=");
		array[i] = ft_strjoin(tmp, node->value);
		free(tmp);
		i++;
		node = node->next;
	}
	array[i] = NULL;
}

char	**env_to_array(t_env *env)
{
	int		count;
	char	**array;

	count = count_env_variables(env);
	array = allocate_env_array(count);
	if (!array)
		return (NULL);

	convert_env_list_to_array(env, array);
	return (array);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 14:48:36 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/19 16:30:21 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char *get_path_env(void)
{
	char *path_env;

	path_env = getenv("PATH");

	if (!path_env)
		return (NULL);

	return (ft_strdup(path_env));
}

char	*build_executable_path(const char *directory, const char *cmd)
{
	char	*temp;
	char	*full_path;

	temp = ft_strjoin(directory, "/");
	full_path = ft_strjoin(temp, cmd);
	free(temp);

	return (full_path);
}

char	*search_executable_in_paths(char *paths, const char *cmd)
{
	char	*token;
	char	*full_path;

	token = ft_strtok(paths, ":");

	while (token)
	{
		full_path = build_executable_path(token, cmd);
		if (!full_path)
			return (NULL);

		if (access(full_path, X_OK) == 0)
			return (full_path);

		free(full_path);
		token = ft_strtok(NULL, ":");
	}
	return (NULL);
}

char	*find_excutable(const char *cmd)
{
	char	*paths;
	char	*full_path;

	paths = get_path_env();
	if (!paths)
		return (NULL);
	full_path = search_executable_in_paths(paths, cmd);

	free(paths);

	return (full_path);
}

int save_stdin(void)
{
    int fd = dup(STDIN_FILENO);
    if (fd < 0)
        perror("dup");
    return fd;
}

void restore_stdin(int saved)
{
    if (dup2(saved, STDIN_FILENO) < 0)
        perror("dup2");
    close(saved);
}

char	*get_executable_path(t_command *cmd)
{
	if (ft_strchr(cmd->args[0], '/') != NULL)
		return (ft_strdup(cmd->args[0]));
	return (find_excutable(cmd->args[0]));
}

int	fork_and_execute(char *exec_path, t_command *cmd, t_data *data)
{
	pid_t pid;
	int status;

	pid = fork();
	if (pid < 0)
	{
		perror("fork");
		free(exec_path);
		return (1);
	}
	if (pid == 0)
	{
		if (handle_redirection(cmd) < 0)
            exit(1);
		if (execve(exec_path, cmd->args, env_to_array(data->env)) == -1)
		{
			perror("execve");
			exit(1);
		}
	}
	waitpid(pid, &status, 0);
	return (WIFEXITED(status)) ? WEXITSTATUS(status) : 1;
}

int	execute_external_command(t_command *cmd, t_data *data)
{
	char	*exec_path;
	int		status;

	exec_path = get_executable_path(cmd);
	if (!exec_path)
		return (127);
	status = fork_and_execute(exec_path, cmd, data);
	free(exec_path);
	return (status);
}

int	execute_command(t_command *cmd, t_data *data)
{
	int	saved_stdin;
	int saved_stdout;
	int	status;

	saved_stdin = save_stdin();
	saved_stdout = dup(STDOUT_FILENO);
	if (saved_stdin < 0)
	{
		perror("dup");
		return (1);
	}
	if (is_builtins(cmd->args[0]))
		return (execute_builtin_with_redir(cmd, data));
	status = execute_external_command(cmd, data);
	restore_stdin(saved_stdin);
    if (dup2(saved_stdout, STDOUT_FILENO) < 0)
        perror("dup2 stdout");
    close(saved_stdout);
	return (status);
}

int execute_full_command(t_command *cmd, t_data *data)
{
	if (cmd->next_pipe)
		return execute_pipeline(cmd, data);
	else
		return execute_command(cmd, data);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 23:51:31 by michel            #+#    #+#             */
/*   Updated: 2025/03/19 16:59:36 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int *create_pipes(int n)
{
	int *pipes;
	int i;

	if (n < 2)
		return (NULL);
	pipes = malloc(2 * (n - 1) * sizeof(int));
	if (!pipes)
		return (NULL);
	i = 0;
	while (i < n - 1)
	{
		if (pipe(&pipes[i * 2]) < 0)
		{
			free(pipes);
			return (NULL);
		}
		i++;
	}
	return (pipes);
}

void	setup_pipes_for_child(int index, t_pipe_info *pi)
{
	if (index > 0)
	{
		if (dup2(pi->pipes[(index - 1) * 2], STDIN_FILENO) < 0)
			exit(1);
	}
	if (index < pi->n - 1)
	{
		if (dup2(pi->pipes[index * 2 + 1], STDOUT_FILENO) < 0)
			exit(1);
	}
}

void	close_unused_pipes(t_pipe_info *pi)
{
	int	j;

	j = 0;
	while (j < 2 * (pi->n - 1))
	{
		close(pi->pipes[j]);
		j++;
	}
}

void	execute_builtin_or_command(t_command *cmd, t_data *data)
{
	char	*exec_path;

	if (is_builtins(cmd->args[0]))
		exit(execute_builtin(cmd->args, data));
	if (ft_strchr(cmd->args[0], '/') != NULL)
		exec_path = ft_strdup(cmd->args[0]);
	else
		exec_path = find_excutable(cmd->args[0]);
	if (!exec_path)
		exit(127);
	execve(exec_path, cmd->args, env_to_array(data->env));
	perror("execve");
	exit(126);
}

int	execute_child(t_command *cmd, int index, t_pipe_info *pi, t_data *data)
{
	setup_pipes_for_child(index, pi);
	close_unused_pipes(pi);
	if (handle_redirection(cmd) < 0)
		exit(1);
	execute_builtin_or_command(cmd, data);
	return (0);
}

int create_child_process(t_command *cmd, int i, t_pipe_info *pi, t_data *data)
{
	pid_t pid;

	pid = fork();
	if (pid < 0)
	{
		perror("fork");
		return (-1);
	}
	if (pid == 0)
		execute_child(cmd, i, pi, data);
	return (pid);
}

void	close_pipeline_pipes(t_pipe_info *pi)
{
	int	i;

	if (pi->pipes)
	{
		i = 0;
		while (i < 2 * (pi->n - 1))
		{
			close(pi->pipes[i]);
			i++;
		}
	}
}

int	wait_for_children(int n)
{
	int	i;
	int	status;
	int	last_status;

	last_status = 0;
	status = 0;
	i = 0;

	while (i < n)
	{
		wait(&status);
		last_status = status;
		i++;
	}
	return (WEXITSTATUS(last_status));
}

int	fork_pipeline(t_command *pipeline, t_pipe_info *pi, t_data *data)
{
	int			i;
	t_command	*cmd;
	pid_t		pid;

	cmd = pipeline;
	i = 0;
	while (cmd)
	{
		pid = create_child_process(cmd, i, pi, data);
		if (pid < 0)
			return (-1);

		cmd = cmd->next_pipe;
		i++;
	}

	close_pipeline_pipes(pi);
	return (wait_for_children(pi->n));
}

int execute_pipeline(t_command *pipeline, t_data *data)
{
	int n;
	t_pipe_info pi;
	int status;

	n = count_commands(pipeline);
	pi.n = n;
	pi.pipes = create_pipes(n);
	if (n > 1 && !pi.pipes)
		return (-1);
	status = fork_pipeline(pipeline, &pi, data);
	if (pi.pipes)
		free(pi.pipes);
	return status;
}

void print_env_array(char **env_array)
{
	int i = 0;
	if (!env_array)
	{
		printf("env_array est NULL\n");
		return;
	}
	while (env_array[i])
	{
		printf("%s\n", env_array[i]);
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   lexer.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: michel <michel@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 16:06:56 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/20 19:30:48 by michel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_token	*allocate_token(void)
{
	t_token	*token;

	token = malloc(sizeof(t_token));
	if (!token)
		perror("malloc");
	return (token);
}

char	*duplicate_token_value(const char *str)
{
	char	*dup;

	dup = strdup(str);
	if (!dup)
		perror("strdup");
	return (dup);
}

t_token_type	determine_token_type(const char *str)
{
	if (strcmp(str, "|") == 0)
		return (PIPE);
	if (strcmp(str, "&&") == 0)
		return (AND_IF);
	if (strcmp(str, "||") == 0)
		return (OR_IF);
	if (strcmp(str, ";") == 0)
		return (SEMICOLON);
	if (strcmp(str, ">") == 0)
		return (REDIR_OUT);
	if (strcmp(str, "<") == 0)
		return (REDIR_IN);
	if (strcmp(str, ">>") == 0)
		return (REDIR_APPEND);
	if (strcmp(str, "<<") == 0)
		return (HEREDOC);
	return (WORD);
}

char *remove_quotes(const char *str)
{
	size_t i;
	size_t j;
	char *new_str;

	new_str = malloc(ft_strlen(str) + 1);
	i = 0;
	j = 0;
	if (!new_str)
		return (NULL);
	while (str[i])
	{
		if (str[i] != '\'' && str[i] != '\"')
		{
			new_str[j] = str[i];
			j++;
		}
		i++;
	}
	new_str[j] = '\0';
	return (new_str);
}

void	initialize_token(t_token *token, const char *str)
{
	char *raw;

	raw = duplicate_token_value(str);
	if (!raw)
	{
		token->value = NULL;
		return ;
	}
	token->value = remove_quotes(raw);
	free(raw);
	token->type = determine_token_type(str);
	token->quoted = false;
	token->next = NULL;
}

t_token	*create_token(const char *str)
{
	t_token	*token;

	token = allocate_token();
	if (!token)
		return (NULL);

	initialize_token(token, str);
	if (!token->value)
	{
		free(token);
		return (NULL);
	}
	return (token);
}

char *collect_token(t_token_state *state, int exit_status, t_env *env)
{
	state->buffer->index = 0;
	while (state->input[state->i])
	{
		if (!state->in_single && !state->in_double && is_whitespace(state->input[state->i]))
			break;
		if (!state->in_single && !state->in_double &&
			(state->input[state->i] == '(' || state->input[state->i] == ')'))
			break;
		process_token_char(state, exit_status, env);
	}
	state->buffer->str[state->buffer->index] = '\0';
	return (ft_strdup(state->buffer->str));
}

void	handle_whitespace(t_token_state *state)
{
	if (!state->in_single && !state->in_double && is_whitespace(state->input[state->i]))
		return ;
}

void	handle_quotes(t_token_state *state)
{
	char	c;

	c = state->input[state->i];

	if (c == '\'' && !state->in_single)
    {
        state->in_single = !state->in_single;
        state->i++;
		return ;
    }
    else if (c == '\"' && !state->in_double)
    {
        state->in_double = !state->in_double;
        state->i++;
		return ;
    }
}

void	handle_escape_character(t_token_state *state)
{
	if (state->input[state->i] == '\\' && !state->in_single)
	{
		state->i++;
		if (!state->input[state->i])
			return ;
	}
}

void	handle_dollar_sign(t_token_state *state, int exit_status, t_env *env)
{
	if (state->input[state->i] == '$' && !state->in_single)
	{
		//printf("DEBUG: Rencontré '$' à l'index %zu, in_single = %d\n", state->i, state->in_single);
		if (state->input[state->i + 1] == '?')
			handle_dollar_question(state->input, &state->i, state->buffer, exit_status);
		else
			handle_dollar_variable(state->input, &state->i, state->buffer, env);
	}
	else
	{
		append_to_buffer(state->buffer, "$");
		state->i++;
	}
}

void	process_regular_character(t_token_state *state)
{
	char	c;

	c = state->input[state->i];
	append_to_buffer(state->buffer, (char[]){c, '\0'});
	state->i++;
}

void	process_token_char(t_token_state *state, int exit_status, t_env *env)
{

	handle_whitespace(state);
	handle_quotes(state);
	handle_escape_character(state);
	handle_dollar_sign(state, exit_status, env);
	process_regular_character(state);
}

t_token_state	initialize_token_state(const char *input)
{
	t_token_state	state;

	state.input = input;
	state.i = 0;
	state.in_single = false;
	state.in_double = false;
	state.buffer = malloc(sizeof(t_buffer));

	if (!state.buffer)
	{
		perror("malloc");
		exit(1);
	}
	state.buffer->cap = 4096;
	state.buffer->index = 0;
	state.buffer->str = malloc(state.buffer->cap);
	if (!state.buffer->str)
	{
		free(state.buffer);
		perror("malloc");
		exit(1);
	}
	return (state);
}

void	cleanup_token_state(t_token_state *state)
{
	free(state->buffer->str);
	free(state->buffer);
}

void append_token_to_list(t_token **head, t_token **tail, t_token *new_token)
{
	if (!*head)
	{
		*head = new_token;
		*tail = new_token;
	}
	else
	{
		(*tail)->next = new_token;
		*tail = new_token;
	}
}

t_token	*process_tokens(t_token_state *state, t_env *env)
{
	t_token	*head;
	t_token	*tail;
	t_token	*token;
	size_t	i;

	i = skip_whitespace(state->input, 0);
	head = NULL;
	tail = NULL;
	while (state->input[i])
	{
		state->i = i;
		state->buffer->index = 0;
		token = create_token(collect_token(state, 0, env));
		if (!token)
			break ;
		append_token_to_list(&head, &tail, token);
		i = skip_whitespace(state->input, state->i);
	}
	return (head);
}

t_token	*lexer(const char *input, t_env *env)
{
	t_token_state	state;
	t_token	*head;

	state = initialize_token_state(input);
	head = process_tokens(&state, env);
	cleanup_token_state(&state);
	return (head);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: michel <michel@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 18:52:32 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/20 19:31:46 by michel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int main(int argc, char **argv, char **envp)
{
    t_data *data;

    (void)argc;
    (void)argv;
    data = malloc(sizeof(t_data));
	if (!data)
	{
		perror("malloc");
		return (1);
	}
    data->env = env_init(envp);
    // char *home = env_get(data->env, "HOME");
    // if (home)
    //     printf("DEBUG: HOME = %s\n", home);
    // else
    //     printf("DEBUG: HOME non trouvée\n");
    data->exit_status = 0;
    data->input = NULL;
    data->tokens = NULL;
    data->cmdlist = NULL;
    rl_catch_signals = 0;
    signal(SIGINT, handle_sigint);
    signal(SIGQUIT, handle_sigquit);
    while ((data->input = readline("minishell$> ")) != NULL)
    {
        if (*data->input)
            add_history(data->input);
        data->tokens = lexer(data->input, data->env);
        free(data->input);
        if (!data->tokens)
            continue ;
        if (!validate_tokens_adv(data->tokens))
        {
            ft_putendl_fd("Syntaxe invalide.\n", 2);
            free_tokens(data->tokens);
            continue ;
        }
        data->cmdlist = parse_line(data->tokens);
        free_tokens(data->tokens);
        if (!data->cmdlist)
            continue ;
        data->exit_status = execute_cmdlist(data->cmdlist, data);
        free_cmdlist(data->cmdlist);
    }
    ft_putendl_fd("exit", 2);
    rl_clear_history();
    free_env(data->env);
    return (data->exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/06 13:31:57 by nicolsan          #+#    #+#             */
/*   Updated: 2025/03/10 16:13:17 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <signal.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/wait.h>


t_env *g_env = NULL;
int g_exit_status = 0;

static t_cmdlist *parse_line(t_token *tokens);
static t_andor *parse_andor(t_token **cur) __attribute__((unused));
static t_command *parse_pipeline(t_token **cur) __attribute__((unused));
static t_command *parse_command(t_token **cur) __attribute__((unused));
static t_command *parse_subshell(t_token **cur) __attribute__((unused));
static int execute_pipeline(t_command *pipeline, t_env *env) __attribute__((unused));
static int execute_andor(t_andor *list, t_env *env) __attribute__((unused));
static void free_cmdlist(t_cmdlist *list);
static char *read_heredoc(const char *delim, bool quoted) __attribute__((unused));
static bool validate_tokens(t_token *tokens) __attribute__((unused));
static char **glob_pattern(const char *pattern) __attribute__((unused));
static void debug_print_redirs(t_redir *redir) __attribute__((unused));
static bool validate_tokens_adv(t_token *tokens) __attribute__((unused));
static char *find_command_path(const char *cmd, t_env *env) __attribute__((unused));
static int execute_single_command(t_command *cmd, t_env *env) __attribute__((unused));


static char *find_command_path(const char *cmd, t_env *env) {
    (void)env;
    if (access(cmd, X_OK) == 0)
        return strdup(cmd);
    return NULL;
}

static bool validate_tokens(t_token *tokens)
{
	int paren_balance = 0;
	t_token *cur = tokens;
	bool prev_was_operator = false;
	while (cur)
	{
		if (strcmp(cur->value, "(") == 0)
			paren_balance++;
		else if (strcmp(cur->value, ")") == 0)
		{
			paren_balance--;
			if (paren_balance < 0)
			{
				fprintf(stderr, "[erreur] Parenthèses desequilibrees : trop de ')'\n");
				return (false);
			}
		}
		if (cur->type == REDIR_IN || cur->type == REDIR_OUT ||
			cur->type == REDIR_APPEND || cur->type == HEREDOC)
			{
			if (!cur->next || cur->next->type != WORD)
			{
				fprintf(stderr, "[erreur] Redirection sans cible : \"%s\"\n", cur->value);
				return (false);
			}
		}
		if (cur->type == AND_IF || cur->type == OR_IF)
		{
			if (prev_was_operator)
			{
				fprintf(stderr, "[erreur] Deux operateurs logiques consecutifs\n");
				return (false);
			}
			prev_was_operator = true;
		}
		else if (cur->type != SEMICOLON)
		{
			prev_was_operator = false;
		}
		cur = cur->next;
	}
	if (paren_balance != 0)
	{
		fprintf(stderr, "[erreur] Parenthèses desequilibrees : balance = %d\n", paren_balance);
		return (false);
	}
	return (true);
}

static bool validate_tokens_adv(t_token *tokens)
{
	if (!tokens)
		return (false);

	if (tokens->type == AND_IF || tokens->type == OR_IF || tokens->type == PIPE)
	{
		fprintf(stderr, "[erreur] Syntax erreur: la commande ne peut commencer par un operateur\n");
		return (false);
	}

	t_token *prev = tokens;
	t_token *cur = tokens->next;
	while (cur)
	{
		if ((cur->type == AND_IF || cur->type == OR_IF || cur->type == PIPE) &&
			(prev->type == AND_IF || prev->type == OR_IF || prev->type == PIPE))
		{
			fprintf(stderr, "[erreur] Syntax erreur: operateurs consecutifs detectes\n");
			return (false);
		}
		if (cur->type == REDIR_IN || cur->type == REDIR_OUT ||
			cur->type == REDIR_APPEND || cur->type == HEREDOC)
		{
			if (!cur->next || cur->next->type != WORD)
			{
				fprintf(stderr, "[erreur] Syntax erreur: redirection \"%s\" sans cible\n", cur->value);
				return (false);
			}
		}
		prev = cur;
		cur = cur->next;
	}

	if (prev->type == AND_IF || prev->type == OR_IF || prev->type == PIPE)
	{
		fprintf(stderr, "[erreur] Syntax error: la commande ne peut se terminer par un operateur\n");
		return (false);
	}

	return (true);
}

void handle_sigint(int sig)
{
	(void)sig;
	fprintf(stderr, "\n[debuger] SIGINT reçu, prompt reaffiche.\n");
	fflush(stderr);
	rl_on_new_line();
	rl_replace_line("", 0);
	rl_redisplay();
}

void handle_sigquit(int sig)
{
	(void)sig;
}

t_env *env_init(char **envp)
{
	(void)envp;
	return NULL;
}

void free_env(t_env *env)
{
	(void)env;
}

static int execute_single_command(t_command *cmd, t_env *env)
{
    pid_t pid;
    int status;

    pid = fork();
    if (pid < 0) {
        perror("fork");
        return 1;
    }
    if (pid == 0) {  /* Enfant */
        /* Ici, vous devriez appliquer les redirections de cmd->redirs,
           par exemple en itérant sur la liste et en appelant open/dup2 */
        char *path = find_command_path(cmd->argv[0], env);
        if (!path) {
            fprintf(stderr, "minishell: %s: command not found\n", cmd->argv[0]);
            exit(127);
        }
        char **envp = env_to_array(env);
        execve(path, cmd->argv, envp);
        perror("execve");
        exit(126);
    } else {  /* Parent */
        waitpid(pid, &status, 0);
        return WEXITSTATUS(status);
    }
}

char *env_get(t_env *env, const char *key)
{
	(void)env;
	(void)key;
	return NULL;
}

void	env_set(t_env **env, const char *key, const char *value)
{
	(void)env;
	(void)key;
	(void)value;
}

void	env_unset(t_env **env, const char *key)
{
	(void)env;
	(void)key;
}

char	**env_to_array(t_env *env)
{
	(void)env;
	return (NULL);
}

int	builtin_echo(char **argv)
{
	(void)argv;
	return (0);
}

int	builtin_cd(char **argv, t_env *env)
{
	(void)argv;
	(void)env;
	return (0);
}

int	builtin_pwd(void)
{
	return (0);
}

int	builtin_export(char **argv, t_env **env)
{
	(void)argv;
	(void)env;
	return (0);
}

int	builtin_unset(char **argv, t_env **env)
{
	(void)argv;
	(void)env;
	return (0);
}

int	builtin_env(t_env *env)
{
	(void)env;
	return (0);
}

int	builtin_exit(char **argv, bool is_child, t_env *env)
{
	(void)argv;
	(void)is_child;
	(void)env;
	exit(0);
	return (0);
}

bool	is_whitespace(char c)
{
	return (c == ' ' || c == '\t');
}

size_t	skip_whitespace(const char *input, size_t i)
{
	while (input[i] && is_whitespace(input[i]))
		i++;
	return (i);
}

static void	append_to_buffer(char *buffer, size_t *index, const char *str)
{
	size_t j = 0;
	while (str[j] && *index < 4096 - 1)
	{
		buffer[*index] = str[j];
		(*index)++;
		j++;
	}
}

static void	handle_dollar_question(const char *input, size_t *i, char *buffer, size_t *index)
{
	(void)input;
	char num[16];
	snprintf(num, sizeof(num), "%d", g_exit_status);
	append_to_buffer(buffer, index, num);
	*i += 2;
}

static void	handle_dollar_variable(const char *input, size_t *i, char *buffer, size_t *index)
{
	size_t start = *i + 1, len = 0;
	while (input[start + len] &&
		   (isalnum(input[start + len]) || input[start + len] == '_'))
		len++;
	if (len)
	{
		char var[256];
		if (len >= sizeof(var))
			len = sizeof(var) - 1;
		strncpy(var, input + start, len);
		var[len] = '\0';
		char *val = env_get(g_env, var);
		if (!val)
			val = "";
		append_to_buffer(buffer, index, val);
		*i = start + len;
	} else
	{
		buffer[(*index)++] = input[(*i)++];
	}
}

static void	process_token_char(const char *input, size_t *i, bool *in_single, bool *in_double, char *buffer, size_t *index)
{
	char c = input[*i];
	if (!(*in_single) && !(*in_double) && is_whitespace(c))
		return;
	if (c == '\'' && !(*in_double))
		{ *in_single = !(*in_single); (*i)++; return; }
	if (c == '\"' && !(*in_single))
		{ *in_double = !(*in_double); (*i)++; return; }
	if (c == '\\' && !(*in_single))
		{ (*i)++; if (!input[*i]) return; c = input[*i]; }
	if (c == '$' && !(*in_single))
	{
		if (input[*i + 1] == '?')
			handle_dollar_question(input, i, buffer, index);
		else
			handle_dollar_variable(input, i, buffer, index);
		return;
	}
	buffer[(*index)++] = c;
	(*i)++;
}

static char *collect_token(const char *input, size_t *i)
{
	char buf[4096];
	size_t idx = 0;
	bool in_single = false, in_double = false;

	if (!in_single && !in_double && (input[*i] == '(' || input[*i] == ')'))
	{
		buf[idx++] = input[*i];
		(*i)++;
		buf[idx] = '\0';
		return strdup(buf);
	}

	while (input[*i])
	{
		if (!in_single && !in_double && is_whitespace(input[*i]))
			break;
		if (!in_single && !in_double && (input[*i] == '(' || input[*i] == ')'))
			break;
		process_token_char(input, i, &in_single, &in_double, buf, &idx);
	}
	buf[idx] = '\0';
	return strdup(buf);
}

static t_token *create_token(const char *str)
{
	t_token *token = malloc(sizeof(t_token));
	if (!token)
	{
		perror("malloc");
		return NULL;
	}
	token->value = strdup(str);
	if (!token->value)
	{
		free(token);
		return NULL;
	}
	if (strcmp(str, "|") == 0)
		token->type = PIPE;
	else if (strcmp(str, "&&") == 0)
		token->type = AND_IF;
	else if (strcmp(str, "||") == 0)
		token->type = OR_IF;
	else if (strcmp(str, ";") == 0)
		token->type = SEMICOLON;
	else if (strcmp(str, ">") == 0)
		token->type = REDIR_OUT;
	else if (strcmp(str, "<") == 0)
		token->type = REDIR_IN;
	else if (strcmp(str, ">>") == 0)
		token->type = REDIR_APPEND;
	else if (strcmp(str, "<<") == 0)
		token->type = HEREDOC;
	else
		token->type = WORD;
	token->quoted = false;
	token->next = NULL;
	return token;
}

t_token	*lexer(const char *input)
{
	fprintf(stderr, "[debuger] Entree dans lexer() : \"%s\"\n", input);
	t_token *head = NULL, *tail = NULL;
	size_t i = skip_whitespace(input, 0);
	while (input[i])
	{
		char *tok_str = collect_token(input, &i);
		if (!tok_str)
			break;
		t_token *token = create_token(tok_str);
		free(tok_str);
		if (!token)
			break;
		if (!head)
			head = tail = token;
		else
		{
			tail->next = token; tail = token;
		}
		fprintf(stderr, "[debuger] Token cree : \"%s\"\n", token->value);
		i = skip_whitespace(input, i);
	}
	fprintf(stderr, "[debuger] Fin du lexer()\n");
	return (head);
}

void free_tokens(t_token *tokens)
{
	(void)tokens;
}

t_cmdlist *parse_line(t_token *tokens)
{
	fprintf(stderr, "[debuger] Entree dans parse_line()\n");
	if (!tokens)
	{
		fprintf(stderr, "[debuger] Aucun token a parser\n");
		return NULL;
	}
	t_cmdlist *head = NULL, *tail = NULL;
	while (tokens)
	{
		t_cmdlist *node = malloc(sizeof(t_cmdlist));
		if (!node)
		{
			perror("malloc"); break;
		}
		node->andor = parse_andor(&tokens);
		node->next = NULL;
		if (!head)
			head = tail = node;
		else
		{
			tail->next = node;
			tail = node;
		}
		if (tokens && tokens->type == SEMICOLON)
			tokens = tokens->next;
	}
	fprintf(stderr, "[debuger] Fin de parse_line()\n");
	return head;
}

static t_andor *init_andor(t_command *pipeline)
{
	t_andor *andor = malloc(sizeof(t_andor));
	if (!andor)
	{ perror("malloc"); return NULL; }
	andor->pipeline = pipeline;
	andor->op = 0;
	andor->next = NULL;
	return andor;
}

static void append_andor(t_andor *head, t_andor *node)
{
	t_andor *cur = head;
	while (cur->next)
		cur = cur->next;
	cur->next = node;
}

static t_andor *parse_andor(t_token **cur)
{
	fprintf(stderr, "[debuger] Entree dans parse_andor()\n");
	t_command *pipeline = parse_pipeline(cur);
	if (!pipeline)
	{
		fprintf(stderr, "[debuger] Aucun pipeline trouve\n");
		return NULL;
	}
	t_andor *head = init_andor(pipeline);
	while (*cur && ((*cur)->type == AND_IF || (*cur)->type == OR_IF))
	{
		fprintf(stderr, "[debuger] Operateur logique trouve : \"%s\"\n", (*cur)->value);
		t_token_type op = (*cur)->type;
		*cur = (*cur)->next;
		t_command *next_pipeline = parse_pipeline(cur);
		if (!next_pipeline)
		{
			fprintf(stderr, "[debuger] Erreur: aucun pipeline après l'operateur\n");
			break;
		}
		t_andor *node = init_andor(next_pipeline);
		if (!node)
			break;
		node->op = op;
		append_andor(head, node);
	}
	fprintf(stderr, "[debuger] Fin de parse_andor()\n");
	return head;
}

static t_command *parse_pipeline(t_token **cur)
{
	fprintf(stderr, "[debuger] Entree dans parse_pipeline()\n");
	t_command *first = parse_command(cur);
	if (!first)
	{
		fprintf(stderr, "[debuger] Aucune commande trouvee dans le pipeline\n");
		return NULL;
	}
	t_command *current = first;
	while (*cur && (*cur)->type == PIPE)
	{
		fprintf(stderr, "[debuger] Token PIPE trouve\n");
		*cur = (*cur)->next;
		t_command *next = parse_command(cur);
		if (!next)
		{
			fprintf(stderr, "[debuger] Erreur: commande après PIPE manquante\n");
			break;
		}
		current->next_pipe = next;
		current = next;
	}
	fprintf(stderr, "[debuger] Fin de parse_pipeline()\n");
	return first;
}

static void debug_print_redirs(t_redir *redir)
{
	while (redir)
	{
		fprintf(stderr, "[debuger] Redirection: type %d, target \"%s\"\n",
				redir->type, redir->target);
		redir = redir->next;
	}
}

static bool is_redirection(t_token *token)
{
	return (token->type == REDIR_IN || token->type == REDIR_OUT ||
			token->type == REDIR_APPEND || token->type == HEREDOC);
}

static void parse_redirection(t_command *cmd, t_token **cur)
{
	t_redir *redir = malloc(sizeof(t_redir));
	if (!redir)
	{ perror("malloc"); return; }
	redir->type = (*cur)->type;
	redir->next = cmd->redirs;
	cmd->redirs = redir;
	*cur = (*cur)->next;
	if (!*cur || (*cur)->type != WORD)
	{
		fprintf(stderr, "[debuger] Erreur: redirection sans cible\n");
		free(redir);
		return;
	}
	if (redir->type == HEREDOC)
		redir->target = read_heredoc((*cur)->value, (*cur)->quoted);
	else
		redir->target = strdup((*cur)->value);
	redir->delim_quoted = (*cur)->quoted;
	*cur = (*cur)->next;
}

static void add_argument_to_cmd(t_command *cmd, const char *arg, size_t *argc, size_t *capacity)
{
	if (*argc + 1 >= *capacity)
	{
		*capacity *= 2;
		char **tmp = realloc(cmd->argv, *capacity * sizeof(char *));
		if (!tmp)
		{ perror("realloc"); return; }
		cmd->argv = tmp;
	}
	cmd->argv[(*argc)++] = strdup(arg);
}

static void handle_word_token(t_token **cur, t_command *cmd,
							  size_t *argc, size_t *capacity)
{
	if (strchr((*cur)->value, '*') && !(*cur)->quoted)
	{
		fprintf(stderr, "[debuger] Wildcard detecte dans : \"%s\"\n", (*cur)->value);
		char **matches = glob_pattern((*cur)->value);
		if (matches)
		{
			size_t mi = 0;
			while (matches[mi])
			{
				fprintf(stderr, "[debuger] Correspondance glob : \"%s\"\n", matches[mi]);
				add_argument_to_cmd(cmd, matches[mi], argc, capacity);
				mi++;
			}
			mi = 0;
			while (matches[mi])
			{
				free(matches[mi]);
				mi++;
			}
			free(matches);
			*cur = (*cur)->next;
			return;
		}
	}
	fprintf(stderr, "[debuger] Ajout d'argument : \"%s\"\n", (*cur)->value);
	add_argument_to_cmd(cmd, (*cur)->value, argc, capacity);
	*cur = (*cur)->next;
}


static t_command *init_command(void)
{
	t_command *cmd = malloc(sizeof(t_command));
	if (!cmd)
	{
		perror("malloc");
		return NULL;
	}
	cmd->subshell = false;
	cmd->subshell_ast = NULL;
	cmd->redirs = NULL;
	cmd->next_pipe = NULL;
	return cmd;
}

static int parse_command_arguments(t_command *cmd, t_token **cur)
{
	size_t capacity = 8, argc = 0;
	cmd->argv = malloc(capacity * sizeof(char *));
	if (!cmd->argv)
	{
		free(cmd);
		return -1;
	}
	while (*cur && (((*cur)->type == WORD) || is_redirection(*cur)))
	{
		if ((*cur)->type == WORD)
			handle_word_token(cur, cmd, &argc, &capacity);
		else
		{
			fprintf(stderr, "[debuger] Redirection detectee : \"%s\"\n", (*cur)->value);
			parse_redirection(cmd, cur);
		}
	}
	cmd->argv[argc] = NULL;
	return (int)argc;
}

static t_command *parse_command(t_token **cur)
{
	fprintf(stderr, "[debuger] Entree dans parse_command()\n");

	if (*cur && strcmp((*cur)->value, "(") == 0)
	{
		t_command *sub = parse_subshell(cur);
		fprintf(stderr, "[debuger] Fin de parse_command() avec subshell\n");
		return sub;
	}
	t_command *cmd = init_command();
	if (!cmd)
		return NULL;

	int argc = parse_command_arguments(cmd, cur);
	if (argc < 0)
		return NULL;

	fprintf(stderr, "[debuger] Fin de parse_command() avec %d argument(s)\n", argc);
	return cmd;
}

static bool match_pattern(const char *pattern, const char *str)
{
	if (!*pattern)
		return !*str;
	if (*pattern == '*')
	{
		size_t skip = 0;
		while (true)
		{
			if (match_pattern(pattern + 1, str + skip))
				return true;
			if (!str[skip])
				break;
			skip++;
		}
		return false;
	}
	return (*pattern == *str) && match_pattern(pattern + 1, str + 1);
}

static void get_dir_and_pattern(const char *pattern, char *dirpath, size_t size, const char **pat)
{
	const char *slash = strrchr(pattern, '/');
	if (slash)
	{
		size_t len = slash - pattern;
		if (len < size)
		{
			strncpy(dirpath, pattern, len);
			dirpath[len] = '\0';
		} else
		{
			strncpy(dirpath, ".", size);
			dirpath[size - 1] = '\0';
		}
		*pat = slash + 1;
	} else
	{
		strncpy(dirpath, ".", size);
		dirpath[size - 1] = '\0';
		*pat = pattern;
	}
}

static char *build_fullpath(const char *dirpath, const char *filename)
{
	if (strcmp(dirpath, ".") == 0)
		return strdup(filename);
	size_t len_dir = strlen(dirpath);
	size_t len_file = strlen(filename);
	char *fullpath = malloc(len_dir + 1 + len_file + 1);
	if (!fullpath)
		return NULL;
	strcpy(fullpath, dirpath);
	fullpath[len_dir] = '/';
	strcpy(fullpath + len_dir + 1, filename);
	return fullpath;
}

static int add_match(char ***matches, size_t *count, size_t *capacity, const char *dirpath, const char *filename)
{
	if (*count >= *capacity)
	{
		*capacity *= 2;
		char **tmp = realloc(*matches, (*capacity) * sizeof(char *));
		if (!tmp)
			return -1;
		*matches = tmp;
	}
	char *fullpath = build_fullpath(dirpath, filename);
	if (!fullpath)
		return 0;
	(*matches)[(*count)++] = fullpath;
	return 1;
}

static char **read_directory_matches(const char *dirpath, const char *pat)
{
	DIR *dir = opendir(dirpath);
	if (!dir)
		return NULL;
	size_t capacity = 8, count = 0;
	char **matches = malloc(capacity * sizeof(char *));
	if (!matches)
	{
		closedir(dir);
		return NULL;
	}
	struct dirent *entry;
	while ((entry = readdir(dir)) != NULL)
	{
		if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
			continue;
		if (match_pattern(pat, entry->d_name))
		{
			if (add_match(&matches, &count, &capacity, dirpath, entry->d_name) == -1)
				break;
		}
	}
	closedir(dir);
	matches = realloc(matches, (count + 1) * sizeof(char *));
	if (matches)
		matches[count] = NULL;
	return matches;
}

static char **glob_pattern(const char *pattern)
{
	if (!pattern)
		return NULL;
	char dirpath[PATH_MAX];
	const char *pat;
	get_dir_and_pattern(pattern, dirpath, sizeof(dirpath), &pat);
	return read_directory_matches(dirpath, pat);
}

static bool skip_opening_paren(t_token **cur)
{
	if (!cur || !*cur || strcmp((*cur)->value, "(") != 0)
	{
		fprintf(stderr, "[debuger] Erreur: pas de '(' pour subshell\n");
		return false;
	}
	*cur = (*cur)->next;
	return true;
}

static t_token *collect_tokens_until_closing(t_token **cur)
{
	t_token *start = *cur;
	t_token *prev = NULL;
	int balance = 1;
	while (*cur)
	{
		if (strcmp((*cur)->value, "(") == 0)
			balance++;
		else if (strcmp((*cur)->value, ")") == 0)
		{
			balance--;
			if (balance == 0)
				break;
		}
		prev = *cur;
		*cur = (*cur)->next;
	}
	if (!*cur || balance != 0)
	{
		fprintf(stderr, "[debuger] Erreur: parenthèses non equilibrees\n");
		return NULL;
	}
	if (prev)
		prev->next = NULL;
	return start;
}

static t_token *extract_subshell_tokens(t_token **cur)
{
	if (!skip_opening_paren(cur))
		return NULL;
	return collect_tokens_until_closing(cur);
}

static t_cmdlist *build_subshell_ast(t_token *tokens)
{
	return parse_line(tokens);
}

static t_command *create_subshell_command(t_cmdlist *sub_ast)
{
	t_command *cmd = malloc(sizeof(t_command));
	if (!cmd)
	{
		perror("malloc");
		return NULL;
	}
	cmd->subshell = true;
	cmd->subshell_ast = sub_ast;
	cmd->argv = NULL;
	cmd->redirs = NULL;
	cmd->next_pipe = NULL;
	return cmd;
}

static t_command *parse_subshell(t_token **cur)
{
	fprintf(stderr, "[debuger] Entree dans parse_subshell()\n");

	t_token *sub_tokens = extract_subshell_tokens(cur);
	if (!sub_tokens)
		return NULL;
	t_cmdlist *sub_ast = build_subshell_ast(sub_tokens);
	*cur = (*cur)->next;
	t_command *cmd = create_subshell_command(sub_ast);
	if (!cmd)
		return NULL;
	fprintf(stderr, "[debuger] Fin de parse_subshell()\n");
	return cmd;
}

static int	execute_pipeline(t_command *pipeline, t_env *env)
{
	(void)pipeline;
	(void)env;
	return 0;
}

static int execute_andor(t_andor *list, t_env *env)
{
	int result = 0;
	bool should_run = true;
	t_andor *node = list;
	while (node)
	{
		if (should_run)
			result = execute_pipeline(node->pipeline, env);
		if (node->op == AND_IF)
			should_run = (result == 0);
		else if (node->op == OR_IF)
			should_run = (result != 0);
		else
			should_run = true;
		node = node->next;
	}
	return result;
}

static void	free_cmdlist(t_cmdlist *list)
{
	(void)list;
}

static void append_line(char **content, size_t *len, size_t *cap, const char *line)
{
	size_t l_len;
	l_len = strlen(line);
	if (*len + l_len + 2 > *cap)
	{
		*cap += l_len + 1024;
		char *tmp = realloc(*content, *cap);
		if (!tmp)
		{
			free(*content);
			exit(1);
		}
		*content = tmp;
	}
	strcpy(*content + *len, line);
	*len += l_len;
	(*content)[(*len)++] = '\n';
	(*content)[*len] = '\0';
}

static char *read_heredoc(const char *delim, bool quoted)
{
	(void)quoted;
	size_t cap = 1024, len = 0;
	char *content = malloc(cap);
	if (!content)
		exit(1);
	content[0] = '\0';

	while (1)
	{
		char *line;
		line = readline("> ");
		if (!line)
		{
			fprintf(stderr, "[debuger] EOF atteint dans heredoc\n");
			break ;
		}
		if (strcmp(line, delim) == 0)
		{
			free(line);
			break ;
		}
		append_line(&content, &len, &cap, line);
		free(line);
	}
	return (content);
}

int	execute_cmdlist(t_cmdlist *commands, t_env *env)
{
	int			last_status;
	t_cmdlist	*node;

	last_status = 0;
	node = commands;
	while (node)
	{
		last_status = execute_andor(node->andor, env);
		node = node->next;
	}
	return (last_status);
}

static void process_input(char *input)
{
	int		 status;
	t_cmdlist   *cmdlist;
	t_token	 *tokens;

	add_history(input);
	tokens = lexer(input);
	free(input);
	if (!tokens)
		return;
	if (!validate_tokens_adv(tokens))
	{
		fprintf(stderr, "[err] Syntaxe invalide.\n");
		free_tokens(tokens);
		return;
	}
	cmdlist = parse_line(tokens);
	free_tokens(tokens);
	if (cmdlist == NULL)
		return;
	status = execute_cmdlist(cmdlist, g_env);
	g_exit_status = status;
	free_cmdlist(cmdlist);
}

void shell_loop(void)
{
	char *input;

	while ((input = readline("minishell$ ")) != NULL)
	{
		if (input[0] != '\0')
			process_input(input);
		else
			free(input);
	}
	fprintf(stderr, "exit\n");
}

int	main(int argc, char **argv, char **envp)
{
	(void)argc;
	(void)argv;
	g_env = env_init(envp);
	rl_catch_signals = 0;
	signal(SIGINT, handle_sigint);
	signal(SIGQUIT, handle_sigquit);
	shell_loop();
	free_env(g_env);
	rl_clear_history();
	return (g_exit_status);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parsing.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 14:47:37 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/18 17:14:13 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_cmdlist *parse_line(t_token *tokens)
{
	t_cmdlist *head;
	t_cmdlist *tail;
	t_cmdlist *node;

	if (!tokens)
		return NULL;
	head = NULL;
	tail = NULL;
	while (tokens)
	{
		node = malloc(sizeof(t_cmdlist));
		if (!node)
		{
			perror("malloc");
			break;
		}
		node->andor = parse_andor(&tokens);
		node->next = NULL;
		if (!head)
			head = tail = node;
		else
		{
			tail->next = node;
			tail = node;
		}
		if (tokens && tokens->type == SEMICOLON)
			tokens = tokens->next;
	}
	return head;
}

t_command *parse_command(t_token **cur)
{
	t_command *cmd;
	t_command *sub;
	int argc;

	init_command();
	if (*cur && ft_strcmp((*cur)->value, "(") == 0)
	{
		sub = parse_subshell(cur);
		return sub;
	}
	cmd = init_command();
	if (!cmd)
		return NULL;
	argc = parse_command_arguments(cmd, cur);
	if (argc < 0)
		return NULL;
	return cmd;
}

t_command *parse_subshell(t_token **cur)
{
	t_token *sub_tokens;
	t_cmdlist *sub_ast;
	t_command *cmd;

	sub_tokens = extract_subshell_tokens(cur);
	if (!sub_tokens)
		return NULL;
	sub_ast = build_subshell_ast(sub_tokens);
	*cur = (*cur)->next;
	cmd = create_subshell_command(sub_ast);
	if (!cmd)
		return NULL;
	return cmd;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 23:29:58 by michel            #+#    #+#             */
/*   Updated: 2025/03/19 13:02:12 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <fcntl.h>

int handle_input_redirection(t_command *cmd)
{
    int fd;

    if (!cmd->input)
        return (0);
    fd = open(cmd->input, O_RDONLY);
    if (fd < 0)
    {
        perror("open input");
        return (-1);
    }
    if (dup2(fd, STDIN_FILENO) < 0)
    {
        perror("dub2 input");
        close(fd);
        return (-1);
    }
    close(fd);
    return (0);
}

int handle_output_trunc_redirection(t_command *cmd)
{
    int fd;

    if (!cmd->output)
        return (0);
    fd = open(cmd->output, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd < 0)
    {
        perror("open output");
        return (-1);
    }
    if (dup2(fd, STDOUT_FILENO) < 0)
    {
        perror("dup2 output");
        close(fd);
        return (-1);
    }
    close(fd);
    return (0);
}

int handle_output_append_redirection(t_command *cmd)
{
    int fd;

    if (!cmd->output)
        return (0);
    fd = open(cmd->output, O_WRONLY | O_CREAT | O_APPEND, 0644);
    if (fd < 0)
    {
        perror("open output (append)");
        return (-1);
    }
    if (dup2(fd, STDOUT_FILENO) < 0)
    {
        perror("dup2 output (append)");
        close(fd);
        return (-1);
    }
    close(fd);
    return (0);
}

int handle_heredoc(t_command *cmd)
{
	int fd;
    char *tmp_name;
    int ret;

    if (!cmd->heredoc)
        return (0);
    fd = open_tmp_heredoc_file(&tmp_name);
    if (fd < 0)
    {
        perror("open heredoc");
        free(tmp_name);
        return (-1);
    }
    ret = read_and_write_heredoc(fd, cmd->input);
    if (ret < 0)
    {
        close(fd);
        free(tmp_name);
        return (-1);
    }
    ret = finalize_heredoc(fd, tmp_name);
    return (ret);
}

int handle_redirection(t_command *cmd)
{
	int ret;

	if (cmd->heredoc)
	{
		ret = handle_heredoc(cmd);
		if (ret < 0)
			return (ret);
	}
	else if (cmd->input)
	{
		ret = handle_input_redirection(cmd);
		if (ret < 0)
			return (ret);
	}
	if (cmd->output)
	{
		if (cmd->append)
			ret = handle_output_append_redirection(cmd);
		else
			ret = handle_output_trunc_redirection(cmd);
		if (ret < 0)
			return (ret);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 18:19:06 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/18 17:12:51 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool validate_tokens(t_token *tokens)
{
	int paren_balance = 0;
	t_token *cur = tokens;
	bool prev_was_operator = false;
	while (cur)
	{
		if (ft_strcmp(cur->value, "(") == 0)
			paren_balance++;
		else if (ft_strcmp(cur->value, ")") == 0)
		{
			paren_balance--;
			if (paren_balance < 0)
				return (false);
		}
		if (cur->type == REDIR_IN || cur->type == REDIR_OUT ||
			cur->type == REDIR_APPEND || cur->type == HEREDOC)
			{
			if (!cur->next || cur->next->type != WORD)
				return (false);
		}
		if (cur->type == AND_IF || cur->type == OR_IF)
		{
			if (prev_was_operator)
				return (false);
			prev_was_operator = true;
		}
		else if (cur->type != SEMICOLON)
		{
			prev_was_operator = false;
		}
		cur = cur->next;
	}
	if (paren_balance != 0)
		return (false);
	return (true);
}

bool validate_tokens_adv(t_token *tokens)
{
	t_token *prev;
	t_token *cur;
	if (!tokens)
		return (false);
	if (tokens->type == AND_IF || tokens->type == OR_IF || tokens->type == PIPE)
		return (false);
	prev = tokens;
	cur = tokens->next;
	while (cur)
	{
		if ((cur->type == AND_IF || cur->type == OR_IF || cur->type == PIPE) &&
			(prev->type == AND_IF || prev->type == OR_IF || prev->type == PIPE))
			return (false);
		if (cur->type == REDIR_IN || cur->type == REDIR_OUT ||
			cur->type == REDIR_APPEND || cur->type == HEREDOC)
		{
			if (!cur->next || cur->next->type != WORD)
				return (false);
		}
		prev = cur;
		cur = cur->next;
	}
	if (prev->type == AND_IF || prev->type == OR_IF || prev->type == PIPE)
		return (false);

	return (true);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils10.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 22:14:29 by michel            #+#    #+#             */
/*   Updated: 2025/03/19 11:57:04 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_cmdlist(t_cmdlist *commands, t_data *data)
{
	int			last_status;
	t_cmdlist	*node;

	last_status = 0;
	node = commands;
	while (node)
	{
		last_status = execute_andor(node->andor, data);
		node = node->next;
	}
	return (last_status);
}

int execute_andor(t_andor *list, t_data *data)
{
	int result = 0;
	bool should_run = true;
	t_andor *node = list;
	while (node)
	{
		if (should_run)
			result = execute_full_command(node->pipeline, data);
		if (node->op == AND_IF)
			should_run = (result == 0);
		else if (node->op == OR_IF)
			should_run = (result != 0);
		else
			should_run = true;
		node = node->next;
	}
	return result;
}

void free_cmdlist(t_cmdlist *list)
{
    t_cmdlist *next;
    while (list)
    {
        next = list->next;
        free_andor(list->andor);
        free(list);
        list = next;
    }
}

void free_andor(t_andor *andor)
{
    t_andor *next;
    while (andor)
    {
        next = andor->next;
        free_command(andor->pipeline);
        free(andor);
        andor = next;
    }
}

int	execute_builtin_with_redir(t_command *cmd, t_data *data)
{
	int	saved_stdout;
	int	ret;

	saved_stdout = dup(STDOUT_FILENO);
	if (saved_stdout < 0)
	{
		perror("dup");
		return (1);
	}
	if (handle_redirection(cmd) < 0)
	{
		close(saved_stdout);
		return (1);
	}
	ret = execute_builtin(cmd->args, data);
	if (dup2(saved_stdout, STDOUT_FILENO) < 0)
	{
		perror("dup2");
		close(saved_stdout);
		return (1);
	}
	close(saved_stdout);
	return (ret);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils11.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 22:24:42 by michel            #+#    #+#             */
/*   Updated: 2025/03/13 16:03:19 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void free_command(t_command *cmd)
{
    int i;
    t_redir *redir;
    t_command *next_pipe;

    if (!cmd)
        return;
    if (cmd->args)
    {
        i = 0;
        while (cmd->args[i])
        {
            free(cmd->args[i]);
            i++;
        }
        free(cmd->args);
    }
    while (cmd->redirs)
    {
        redir = cmd->redirs;
        cmd->redirs = cmd->redirs->next;
        if (redir->target)
            free(redir->target);
        free(redir);
    }
    next_pipe = cmd->next_pipe;
    free(cmd);
    free_command(next_pipe);
}

int count_commands(t_command *pipeline)
{
    int count = 0;
    while (pipeline)
    {
        count++;
        pipeline = pipeline->next_pipe;
    }
    return (count);
}

t_command *init_command(void)
{
    t_command *cmd;

    cmd = malloc(sizeof(t_command));
    if (!cmd)
    {
        perror("malloc");
        return NULL;
    }
    cmd->args = NULL;
    cmd->input = NULL;
    cmd->output = NULL;
    cmd->append = 0;
    cmd->heredoc = 0;
    cmd->subshell = false;
    cmd->redirs = NULL;
    cmd->next_pipe = NULL;
    cmd->subshell_ast = NULL;
    return cmd;
}

int	update_env_var(t_data *data, char *key, char *value)
{
	t_env	*node;
	size_t	key_len;

	node = data->env;
	key_len = ft_strlen(key);
	while (node)
	{
		if (ft_strncmp(node->key, key, key_len) == 0 && node->key[key_len] == '\0')
		{
			free(node->value);
			node->value = ft_strdup(value);
			return (1);
		}
		node = node->next;
	}
	return (0);
}

int	add_env_var(t_data *data, char *key, char *value)
{
	t_env	*new_node;

	new_node = malloc(sizeof(t_env));
	if (!new_node)
	{
		perror("malloc");
		free(key);
		free(value);
		return (1);
	}
	new_node->key = key;
	new_node->value = value;
	new_node->next = data->env;
	data->env = new_node;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils2.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/09 02:03:50 by michel            #+#    #+#             */
/*   Updated: 2025/03/18 17:19:35 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char *generate_tmp_name(void)
{
    static int counter;
    char *prefix;
    char *num_str;
    char *tmp_name;
    static int init;

    if (!init)
    {
        counter = 0;
        init = 1;
    }
    prefix = "/tmp/minishell_heredoc_";
    num_str = ft_itoa(counter);
    tmp_name = ft_strjoin(prefix, num_str);
    free(num_str);
    counter++;
    return (tmp_name);
}

int open_tmp_heredoc_file(char **tmp_name)
{
    int fd;

    *tmp_name = generate_tmp_name();
    unlink(*tmp_name);
    fd = open(*tmp_name, O_WRONLY | O_CREAT | O_EXCL, 0600);
    return (fd);
}

int read_and_write_heredoc(int fd, const char *delimiter)
{
    char *line;

    while (1)
    {
        line = readline("> ");
        if (!line || ft_strcmp(line, delimiter) == 0)
        {
            free(line);
            break;
        }
        write(fd, line, ft_strlen(line));
        write(fd, "\n", 1);
        free(line);
    }
    return (0);
}

int finalize_heredoc(int fd, char *tmp_name)
{
    int ret;

    close(fd);
	fd = open(tmp_name, O_RDONLY);
	if (fd < 0)
	{
		perror("open heredoc (finalize)");
		free(tmp_name);
		return (-1);
	}
    ret = dup2(fd, STDIN_FILENO);
    close(fd);
    unlink(tmp_name);
    free(tmp_name);
    if (ret < 0)
        return (-1);
    return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils3.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: michel <michel@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 16:21:31 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/20 19:33:16 by michel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool	is_whitespace(char c)
{
	return (c == ' ' || c == '\t');
}

size_t	skip_whitespace(const char *input, size_t i)
{
	while (input[i] && is_whitespace(input[i]))
		i++;
	return (i);
}

void append_to_buffer(t_buffer *buf, const char *s)
{
    size_t len;
	size_t new_cap;
	char *new_str;

	len = ft_strlen(s);
    if (buf->index + len + 1 > buf->cap)
    {
        new_cap = buf->cap + len + 1024;
        new_str = realloc(buf->str, new_cap);
        if (!new_str)
        {
            free(buf->str);
            buf->str = NULL;
            buf->cap = 0;
            return;
        }
        buf->str = new_str;
        buf->cap = new_cap;
    }
    ft_strlcpy(buf->str + buf->index, s, len + 1);
    buf->index += len;
}

void	handle_dollar_question(const char *input, size_t *i, t_buffer *buf, int exit_status)
{
	char *num_str;

	(void)input;
	num_str = ft_itoa(exit_status);
	if (!num_str)
		return;
	append_to_buffer(buf, num_str);
	free(num_str);
	*i += 2;
}

void	handle_dollar_variable(const char *input, size_t *i, t_buffer *buf, t_env *env)
{
	size_t start;
	size_t len;
	char var[256];
	char *val;

	start = *i + 1;
	len = 0;
	while (input[start + len] &&
		   (isalnum(input[start + len]) || input[start + len] == '_'))
		len++;
	if (len)
	{
		if (len >= sizeof(var))
			len = sizeof(var) - 1;
		ft_strncpy(var, input + start, len);
		var[len] = '\0';
		//printf("DEBUG: Variable extraite = %s\n", var);
		val = env_get(env, var);
		if (!val)
		{
		//printf("DEBUG: La variable %s n'a pas été trouvée\n", var);
			val = "";
		}
		else
			//printf("DEBUG: Valeur trouvée pour %s = %s\n", var, val);
		append_to_buffer(buf, val);
		*i = start + len;
	}
	else
		buf->str[buf->index++] = input[(*i)++];
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils4.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 15:03:00 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/19 12:41:10 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_cmdlist *build_subshell_ast(t_token *tokens)
{
	return parse_line(tokens);
}

t_token *extract_subshell_tokens(t_token **cur)
{
	if (!skip_opening_paren(cur))
		return NULL;
	return collect_tokens_until_closing(cur);
}

t_command *create_subshell_command(t_cmdlist *sub_ast)
{
	t_command *cmd;

	cmd = malloc(sizeof(t_command));
	if (!cmd)
	{
		perror("malloc");
		return NULL;
	}
	cmd->subshell = true;
	cmd->subshell_ast = sub_ast;
	cmd->args = NULL;
	cmd->redirs = NULL;
	cmd->next_pipe = NULL;
	return cmd;
}
int parse_command_arguments(t_command *cmd, t_token **cur)
{
	size_t capacity;
	size_t argc;

	capacity = 8;
	argc = 0;
	cmd->args = malloc(capacity * sizeof(char *));
	if (!cmd->args)
	{
		free(cmd);
		return -1;
	}
	while (*cur && (((*cur)->type == WORD) || is_redirection(*cur)))
	{
		if ((*cur)->type == WORD)
			handle_word_token(cur, cmd, &argc, &capacity);
		else
			parse_redirection(cmd, cur);
	}
	cmd->args[argc] = NULL;
	return (int)argc;
}

void handle_word_token(t_token **cur, t_command *cmd, size_t *argc, size_t *capacity)
{
	char **matches;
	size_t mi;

	if (strchr((*cur)->value, '*') && !(*cur)->quoted)
	{
		matches = glob_pattern((*cur)->value);
		if (matches && matches[0])
		{
			mi = 0;
			while (matches[mi])
			{
				add_argument_to_cmd(cmd, matches[mi], argc, capacity);
				mi++;
			}
			mi = 0;
			while (matches[mi])
			{
				free(matches[mi]);
				mi++;
			}
			free(matches);
			*cur = (*cur)->next;
			return;
		}
		else
		{
			if (matches)
				free(matches);
		}
	}
	add_argument_to_cmd(cmd, (*cur)->value, argc, capacity);
	*cur = (*cur)->next;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils5.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 15:07:51 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/18 17:10:50 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft/libft.h"
#include "minishell.h"

void add_argument_to_cmd(t_command *cmd, const char *arg, size_t *argc, size_t *capacity)
{
	char **tmp;

	if (*argc + 1 >= *capacity)
	{
		*capacity *= 2;
		tmp = realloc(cmd->args, *capacity * sizeof(char *));
		if (!tmp)
		{
			perror("realloc");
			return;
		}
		cmd->args = tmp;
	}
	cmd->args[(*argc)++] = ft_strdup(arg);
}

void parse_redirection(t_command *cmd, t_token **cur)
{
	if ((*cur)->type == REDIR_OUT || (*cur)->type == REDIR_APPEND)
	{
		cmd->output = ft_strdup((*cur)->next->value);
		cmd->append = ((*cur)->type == REDIR_APPEND);
		*cur = (*cur)->next->next;
	}
	else if ((*cur)->type == REDIR_IN)
	{
		cmd->input = ft_strdup((*cur)->next->value);
		*cur = (*cur)->next->next;
	}
	else if ((*cur)->type == HEREDOC)
	{
		cmd->heredoc = 1;
		cmd->input = ft_strdup((*cur)->next->value);
		*cur = (*cur)->next->next;
	}
}

t_andor *parse_andor(t_token **cur)
{
	t_command *pipeline;
	t_andor *head;
	t_token_type op;
	t_command *next_pipeline;
	t_andor *node;

	pipeline = parse_pipeline(cur);
	if (!pipeline)
		return NULL;
	head = init_andor(pipeline);
	while (*cur && ((*cur)->type == AND_IF || (*cur)->type == OR_IF))
	{
		op = (*cur)->type;
		*cur = (*cur)->next;
		next_pipeline = parse_pipeline(cur);
		if (!next_pipeline)
			break;
		node = init_andor(next_pipeline);
		if (!node)
			break;
		node->op = op;
		append_andor(head, node);
	}
	return head;
}

void append_andor(t_andor *head, t_andor *node)
{
	t_andor *cur;

	cur = head;
	while (cur->next)
		cur = cur->next;
	cur->next = node;
}

t_andor *init_andor(t_command *pipeline)
{
	t_andor *andor;

	andor = malloc(sizeof(t_andor));
	if (!andor)
	{ perror("malloc"); return NULL; }
	andor->pipeline = pipeline;
	andor->op = 0;
	andor->next = NULL;
	return andor;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils6.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 15:34:47 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/18 17:10:21 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <linux/limits.h>

bool skip_opening_paren(t_token **cur)
{
	if (!cur || !*cur || ft_strcmp((*cur)->value, "(") != 0)
		return false;
	*cur = (*cur)->next;
	return true;
}

t_token *collect_tokens_until_closing(t_token **cur)
{
	t_token *start;
	t_token *prev;
	int balance;

	start = *cur;
	prev = NULL;
	balance = 1;
	while (*cur)
	{
		if (ft_strcmp((*cur)->value, "(") == 0)
			balance++;
		else if (ft_strcmp((*cur)->value, ")") == 0)
		{
			balance--;
			if (balance == 0)
				break;
		}
		prev = *cur;
		*cur = (*cur)->next;
	}
	if (!*cur || balance != 0)
		return NULL;
	if (prev)
		prev->next = NULL;
	return start;
}

char **glob_pattern(const char *pattern)
{
	char dirpath[PATH_MAX];
	const char *pat;

	if (!pattern)
		return NULL;
	get_dir_and_pattern(pattern, dirpath, sizeof(dirpath), &pat);
	return read_directory_matches(dirpath, pat);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils7.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 16:46:08 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/19 12:18:51 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char *read_heredoc(const char *delim, bool quoted)
{
	(void)quoted;
	size_t cap;
	size_t len;
	char *content;
	char *line;

	cap = 1024;
	len = 0;
	content = malloc(cap);
	if (!content)
		exit(1);
	content[0] = '\0';
	while (1)
	{
		line = readline("> ");
		if (!line)
			break ;
		if (ft_strcmp(line, delim) == 0)
		{
			free(line);
			break ;
		}
		append_line(&content, &len, &cap, line);
		free(line);
	}
	return (content);
}

t_command *parse_pipeline(t_token **cur)
{
	t_command *first;
	t_command *current;
	t_command *next;

	first = parse_command(cur);
	if (!first)
		return NULL;
	current = first;
	while (*cur && (*cur)->type == PIPE)
	{
		*cur = (*cur)->next;
		next = parse_command(cur);
		if (!next)
			break;
		current->next_pipe = next;
		current = next;
	}
	return first;
}

void get_dir_and_pattern(const char *pattern, char *dirpath, size_t size, const char **pat)
{
	const char *slash;
	size_t len;

	slash = strrchr(pattern, '/');
	if (slash)
	{
		len = slash - pattern;
		if (len < size)
		{
			ft_strncpy(dirpath, pattern, len);
			dirpath[len] = '\0';
		} else
		{
			ft_strncpy(dirpath, ".", size);
			dirpath[size - 1] = '\0';
		}
		*pat = slash + 1;
	} else
	{
		ft_strncpy(dirpath, ".", size);
		dirpath[size - 1] = '\0';
		*pat = pattern;
	}
}

char **read_directory_matches(const char *dirpath, const char *pat)
{
	DIR *dir;
	char **matches;
	size_t capacity;
	size_t count;
	struct dirent *entry;


	dir = opendir(dirpath);
	if (!dir)
		return NULL;
	capacity = 8;
	count = 0;
	matches = malloc(capacity * sizeof(char *));
	if (!matches)
	{
		closedir(dir);
		return NULL;
	}
	while ((entry = readdir(dir)) != NULL)
	{
		if (ft_strcmp(entry->d_name, ".") == 0 || ft_strcmp(entry->d_name, "..") == 0)
			continue;
		if (match_pattern(pat, entry->d_name))
		{
			if (add_match(&matches, &count, &capacity, dirpath, entry->d_name) == -1)
				break;
		}
	}
	closedir(dir);
	matches = realloc(matches, (count + 1) * sizeof(char *));
	if (matches)
		matches[count] = NULL;
	return matches;
}

void append_line(char **content, size_t *len, size_t *cap, const char *line)
{
	size_t l_len;
	char *tmp;

	l_len = ft_strlen(line);
	if (*len + l_len + 2 > *cap)
	{
		*cap += l_len + 1024;
		tmp = realloc(*content, *cap);
		if (!tmp)
		{
			free(*content);
			exit(1);
		}
		*content = tmp;
	}
	ft_strcpy(*content + *len, line);
	*len += l_len;
	(*content)[(*len)++] = '\n';
	(*content)[*len] = '\0';
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils8.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 17:24:30 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/19 12:21:54 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

bool match_pattern(const char *pattern, const char *str)
{
	size_t skip;

	if (!*pattern)
		return !*str;
	if (*pattern == '*')
	{
		skip = 0;
		while (true)
		{
			if (match_pattern(pattern + 1, str + skip))
				return true;
			if (!str[skip])
				break;
			skip++;
		}
		return false;
	}
	return (*pattern == *str) && match_pattern(pattern + 1, str + 1);
}

bool is_redirection(t_token *token)
{
	return (token->type == REDIR_IN || token->type == REDIR_OUT ||
			token->type == REDIR_APPEND || token->type == HEREDOC);
}

void free_env(t_env *env)
{
    t_env *tmp;
    while (env)
    {
        tmp = env->next;
        free(env->key);
        free(env->value);
        free(env);
        env = tmp;
    }
}

char *ft_strncpy(char *dest, const char *src, size_t n)
{
    size_t i;

    i = 0;
    while (i < n && src[i] != '\0')
    {
        dest[i] = src[i];
        i++;
    }
    while (i < n)
    {
        dest[i] = '\0';
        i++;
    }
    return dest;
}

int add_match(char ***matches, size_t *count, size_t *capacity, const char *dirpath, const char *filename)
{
	char *fullpath;
	char **tmp;

	if (*count >= *capacity)
	{
		*capacity *= 2;
		tmp = realloc(*matches, (*capacity) * sizeof(char *));
		if (!tmp)
			return -1;
		*matches = tmp;
	}
	fullpath = build_fullpath(dirpath, filename);
	if (!fullpath)
		return 0;
	(*matches)[(*count)++] = fullpath;
	return 1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils9.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mm-furi <mm-furi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 20:58:02 by michel            #+#    #+#             */
/*   Updated: 2025/03/19 17:28:20 by mm-furi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char *build_fullpath(const char *dirpath, const char *filename)
{
    size_t len_dir;
    size_t len_file;
    char *fullpath;

	if (ft_strcmp(dirpath, ".") == 0)
		return ft_strdup(filename);
    len_dir = ft_strlen(dirpath);
	len_file = ft_strlen(filename);
	fullpath = malloc(len_dir + 1 + len_file + 1);
	if (!fullpath)
		return NULL;
	ft_strcpy(fullpath, dirpath);
	fullpath[len_dir] = '/';
	ft_strcpy(fullpath + len_dir + 1, filename);
	return fullpath;
}

char *ft_strcpy(char *dest, const char *src)
{
    int i = 0;
    while (src[i] != '\0')
    {
        dest[i] = src[i];
        i++;
    }
    dest[i] = '\0';
    return dest;
}

void handle_sigint(int sig)
{
	(void)sig;
	rl_on_new_line();
    write(STDOUT_FILENO, "^C", 2);
    write(STDOUT_FILENO, "\n", 1);
	rl_replace_line("", 0);
	rl_redisplay();
}

void handle_sigquit(int sig)
{
	(void)sig;
}

void free_tokens(t_token *tokens)
{
    t_token *tmp;

    while (tokens)
    {
        tmp = tokens->next;
        free(tokens->value);
        free(tokens);
        tokens = tmp;
    }
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: michel <michel@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/05 17:34:08 by mm-furi           #+#    #+#             */
/*   Updated: 2025/03/13 01:45:28 by michel           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

# include "minishell.h"

char	*ft_strtok(char *s, const char *delim)
{
	static char	*static_str;
	char		*token;

	if (s)
		static_str = s;
	if (!static_str || !delim)
		return (NULL);
	while (*static_str && ft_strchr(delim, *static_str))
		static_str++;
	if (!*static_str)
	{
		static_str = NULL;
		return (NULL);
	}
	token = static_str;
	while (*static_str && !ft_strchr(delim, *static_str))
		static_str++;
	if (*static_str)
	{
		*static_str = '\0';
		static_str++;
	}
	return (token);
}

int ft_strcmp(const char *s1, const char *s2)
{
	int i;

	i = 0;
	while (s1[i] || s2[i])
	{
		if (s1[i] != s2[i])
			return (s1[i] - s2[i]);
		i++;
	}
	return (s1[i] - s2[i]);
}

int find_env_index(char **env, char *var)
{
	int i;
	size_t key_len;
	char *eq;

	i = 0;
	eq = ft_strchr(var, '=');
	if (!eq)
		return (-1);
	key_len = eq - var;
	while (env[i])
	{
		if (!ft_strncmp(env[i], var, key_len) && env[i][key_len] == '=')
			return (i);
		i++;
	}
	return (-1);
}

char **add_env_variable(char **env, char *new_var)
{
	int cnt;
	int i;
	char **new_env;

	cnt = 0;
	while (env[cnt])
		cnt++;
	new_env = malloc((cnt + 2) * sizeof(char *));
	if (!new_env)
		return (NULL);
	i = 0;
	while (i < cnt)
	{
		new_env[i] = env[i];
		i++;
	}
	new_env[i] = ft_strdup(new_var);
	new_env[i + 1] = NULL;
	free(env);
	return (new_env);
}

int find_env_index_unset(char **env, char *var)
{
	int i;
	int len;

	i = 0;
	len = ft_strlen(var);
	while (env[i])
	{
		if (!ft_strncmp(env[i], var, len) && env[i][len] == '=')
			return (i);
		i++;
	}
	return (-1);
}
